<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cutting 3D Pro v6.5 (Export & Custom Colors)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #121212; color: #eee; font-family: "Microsoft JhengHei", sans-serif; user-select: none; }
        
        /* å´æ¬„ */
        #sidebar {
            position: absolute; top: 0; left: 0; width: 380px; height: 100vh;
            background: rgba(30, 30, 30, 0.95); overflow-y: auto; padding: 0;
            box-sizing: border-box; border-right: 1px solid #444; backdrop-filter: blur(5px);
            display: flex; flex-direction: column; z-index: 20;
        }

        .header-area { padding: 12px 15px; background: #1a1a1a; border-bottom: 1px solid #444; }
        .app-title { color: #4FC3F7; font-size: 18px; margin: 0 0 8px 0; font-weight: bold; display: flex; justify-content: space-between; align-items: center; }
        
        /* é¡¯ç¤ºéš±è—æ§åˆ¶åˆ— */
        .control-bar-label { font-size: 11px; color: #888; margin-bottom: 2px; display: block;}
        .vis-bar { display: flex; gap: 5px; margin-bottom: 10px; background: #222; padding: 5px; border-radius: 4px; border: 1px solid #444; }
        
        .vis-btn { flex: 1; padding: 4px; font-size: 16px; cursor: pointer; border: 1px solid #555; background: #333; color: #666; border-radius: 3px; text-align: center; transition:0.2s; }
        .vis-btn:hover { background: #444; }
        .vis-btn.active { background: #00E676; color: #000; border-color: #00E676; box-shadow: 0 0 5px rgba(0, 230, 118, 0.3); }

        .sel-btn { flex: 1; padding: 6px 4px; font-size: 13px; cursor: pointer; border: 1px solid #555; background: #333; color: #aaa; border-radius: 3px; text-align: center; transition:0.2s; font-weight: bold; }
        .sel-btn:hover { background: #444; color: #fff; }
        .sel-btn.active { background: #2979FF; color: #fff; border-color: #2979FF; box-shadow: 0 0 8px rgba(41, 121, 255, 0.4); }

        /* åˆ†é  */
        .tabs { display: flex; background: #222; border-bottom: 1px solid #444; }
        .tab-btn { flex: 1; padding: 10px 0; background: #222; color: #888; border: none; cursor: pointer; font-weight: bold; border-bottom: 3px solid transparent; transition: 0.2s; font-size: 13px;}
        .tab-btn.active { color: #fff; background: #333; border-bottom-color: #00E676; }
        .tab-content { padding: 15px; display: none; overflow-y: auto; flex: 1; }
        .tab-content.active { display: block; }

        /* UI å…ƒä»¶ */
        .group { background: rgba(255,255,255,0.03); padding: 10px; border-radius: 6px; border: 1px solid #444; margin-bottom: 10px; }
        .group-title { font-weight: bold; margin-bottom: 8px; display: flex; justify-content:space-between; align-items:center; font-size: 13px; color: #aaa; }
        .row { display: flex; align-items: center; margin-bottom: 6px; gap: 5px; }
        label { flex: 0 0 60px; font-size: 12px; color: #ccc; text-align: right; margin-right: 5px;}
        input[type="number"] { width: 50px; background: #111; border: 1px solid #555; color: #4FC3F7; padding: 4px; border-radius: 4px; font-size: 12px; text-align: right; }
        input[type="range"] { flex: 1; cursor: pointer; height: 6px; }
        input[type="text"] { background: #111; border: 1px solid #555; color: white; padding: 5px; border-radius: 4px; }
        input[type="color"] { background: none; border: none; width: 25px; height: 25px; cursor: pointer; padding: 0; vertical-align: middle;}
        
        button.action-btn { width: 100%; padding: 8px; background: #00695C; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 13px; margin-top: 5px;}
        button.action-btn:hover { background: #00897B; }
        .tool-btn { background: #444; padding: 4px 8px; border-radius: 4px; cursor: pointer; border: 1px solid #666; color: white; font-size: 12px;}
        .tool-btn:hover { background: #666; }

        .export-row { display: flex; gap: 5px; margin-bottom: 10px; }
        .export-btn { flex: 1; background: #37474F; color: #ECEFF1; border: 1px solid #546E7A; padding: 6px; border-radius: 4px; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; gap: 5px; }
        .export-btn:hover { background: #455A64; }
        
        /* å½ˆçª—æ¨£å¼ */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 999; display: none; justify-content: center; align-items: center; }
        .modal { background: #222; width: 600px; max-height: 85vh; padding: 20px; border-radius: 8px; border: 1px solid #444; display: flex; flex-direction: column; gap: 10px; color: #eee; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .project-card { display: flex; gap: 10px; background: #333; padding: 10px; border-radius: 6px; margin-bottom: 8px; border: 1px solid #444; align-items: center;}
        .project-card:hover { border-color: #00E676; background: #3a3a3a; }
        .project-thumb { width: 100px; height: 70px; background: #000; object-fit: cover; border-radius: 4px; cursor: pointer;}
        .project-info { flex: 1; display: flex; flex-direction: column; gap: 4px; }
        .default-badge { color: #FFD700; font-size: 18px; cursor: pointer; padding: 5px; }
        .default-badge.inactive { color: #555; filter: grayscale(1); }

        /* è¦–è§’èˆ‡Gizmo */
        #view-controls { position: absolute; top: 15px; right: 15px; display: flex; flex-direction: column; gap: 5px; z-index: 10; }
        .view-btn { width: 40px; height: 40px; background: rgba(50,50,50,0.8); color: white; border: 1px solid #666; border-radius: 6px; cursor: pointer; font-weight: bold; display: flex; justify-content: center; align-items: center; }
        
        #gizmo-panel { position: absolute; bottom: 20px; right: 20px; background: rgba(30,30,30,0.9); padding: 10px; border-radius: 8px; border: 1px solid #555; width: 150px; z-index: 10;}
        .gizmo-row { display: flex; gap: 5px; margin-top: 5px;}
        .gizmo-btn { flex: 1; padding: 5px; font-size: 11px; cursor: pointer; background: #444; color: #ddd; border: 1px solid #666; border-radius: 4px; }
        .gizmo-btn.active { background: #FF9800; color: #000; border-color: #FF9800; }

        /* æ¨™è¨»ç³»çµ± HTML Overlay */
        #label-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none; z-index: 5; }
        /* å¼•å°ç·šç•«å¸ƒ */
        #leader-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 4; }
        
        .annotation-label { 
            position: absolute; 
            padding: 4px 8px; 
            border-radius: 4px; 
            font-size: 12px; 
            pointer-events: auto; 
            white-space: nowrap; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.5); 
            display: flex; gap: 5px; align-items: center; 
            border: 1px solid transparent; 
            transition: background 0.2s, border 0.2s, opacity 0.2s;
            cursor: move; 
            backdrop-filter: blur(2px);
        }
        .annotation-label:hover { z-index: 100; border-color: rgba(255,255,255,0.8); box-shadow: 0 4px 12px rgba(0,0,0,0.8); }
        .annotation-label input { background: transparent; border: none; color: inherit; font: inherit; text-align: center; min-width: 50px; outline: none; cursor: text; }
        .close-btn { width: 18px; height: 18px; background: #e53935; color: white; border-radius: 50%; font-size: 12px; font-weight:bold; display: flex; justify-content: center; align-items: center; cursor: pointer; opacity: 0; transition: 0.2s; border: none; }
        .annotation-label:hover .close-btn { opacity: 1; }

        #snap-hint { position: absolute; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); border: 1px solid #00E676; color: #00E676; padding: 8px 15px; border-radius: 20px; font-weight: bold; pointer-events: none; display: none; z-index: 30; }

        #loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #121212; display: flex; justify-content: center; align-items: center; z-index: 9999; color: white; font-size: 20px; transition: opacity 0.5s; }

        #impact-canvas { display: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
                "three-bvh-csg": "https://esm.sh/three-bvh-csg@0.0.16?deps=three@0.160.0",
                "firebase-app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
                "firebase-firestore": "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js"
            }
        }
    </script>
</head>
<body>

<div id="loader">â˜ï¸ ç³»çµ±é€£ç·šä¸­...</div>
<div id="snap-hint">æ¨¡å¼æç¤º</div>

<div id="label-container"></div>
<canvas id="leader-canvas"></canvas>
<canvas id="impact-canvas" width="512" height="512"></canvas>

<div id="modal-save" class="modal-overlay">
    <div class="modal">
        <h3 style="margin:0;color:#4FC3F7">ğŸ’¾ å„²å­˜è‡³é›²ç«¯</h3>
        <div style="background:#111; padding:10px; border-radius:4px; text-align:center;">
            <img id="save-preview-img" style="max-width:100%; max-height:200px; border:1px solid #444;">
        </div>
        <input type="text" id="save-name" placeholder="å°ˆæ¡ˆåç¨±" style="width:96%; padding:10px; background:#111; border:1px solid #555; color:white;">
        <textarea id="save-desc" rows="2" placeholder="æè¿° (é¸å¡«)..." style="width:96%; padding:10px; background:#111; border:1px solid #555; color:white; resize:none;"></textarea>
        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:10px;">
            <button class="tool-btn" onclick="document.getElementById('modal-save').style.display='none'">å–æ¶ˆ</button>
            <button class="action-btn" style="margin:0; width:auto; background:#E65100" onclick="confirmSave()">ç¢ºèªä¸Šå‚³</button>
        </div>
    </div>
</div>

<div id="modal-load" class="modal-overlay">
    <div class="modal" style="height: 700px; width: 700px;">
        <h3 style="margin:0;color:#4FC3F7">ğŸ“‚ é›²ç«¯å°ˆæ¡ˆåº«</h3>
        <div style="display:flex; gap:10px; margin-bottom:10px;">
            <input type="text" id="search-proj" placeholder="æœå°‹å°ˆæ¡ˆ..." oninput="filterProjects()" style="flex:1;">
        </div>
        <div id="project-list" style="overflow-y:auto; flex:1; padding-right:5px;">
            <div style="text-align:center; padding:20px; color:#666;">è¼‰å…¥ä¸­...</div>
        </div>
        <button class="tool-btn" onclick="document.getElementById('modal-load').style.display='none'" style="align-self:flex-end;">é—œé–‰</button>
    </div>
</div>

<div id="view-controls">
    <div class="view-btn" onclick="setView('top')">ä¸Š</div>
    <div class="view-btn" onclick="setView('front')">å‰</div>
    <div class="view-btn" onclick="setView('side')">å³</div>
    <div class="view-btn" onclick="setView('iso')">ISO</div>
</div>

<div id="gizmo-panel">
    <div style="font-size:12px;color:#aaa;text-align:center">è®Šæ›æ§åˆ¶</div>
    <div class="gizmo-row">
        <button class="gizmo-btn active" id="mode-translate" onclick="setGizmoMode('translate')">ç§»å‹• Move</button>
        <button class="gizmo-btn" id="mode-rotate" onclick="setGizmoMode('rotate')">æ—‹è½‰ Rot</button>
    </div>
    <div class="gizmo-row">
        <button class="gizmo-btn" onclick="setGizmoAxis('X')">X</button>
        <button class="gizmo-btn" onclick="setGizmoAxis('Y')">Y</button>
        <button class="gizmo-btn" onclick="setGizmoAxis('Z')">Z</button>
    </div>
    <button class="gizmo-btn" onclick="setGizmoAxis(null)" style="width:100%;margin-top:2px">è‡ªç”± (Free)</button>
</div>

<div id="sidebar">
    <div class="header-area">
        <div class="app-title">
            <span>Cutting 3D Pro</span>
            <div style="display:flex; gap:5px;">
                <button class="tool-btn" onclick="initFromDefault()" title="åˆå§‹åŒ– (è¼‰å…¥é è¨­)">ğŸ”„ é‡ç½®</button>
                <button class="tool-btn" onclick="openLoadModal()" title="é–‹å•Ÿé›²ç«¯å°ˆæ¡ˆ">ğŸ“‚</button>
                <button class="tool-btn" style="background:#E65100" onclick="openSaveModal()" title="å„²å­˜å°ˆæ¡ˆ">ğŸ’¾</button>
            </div>
        </div>
        
        <div class="export-row">
             <button class="export-btn" onclick="exportImage()">ğŸ“· å­˜åœ– (PPT)</button>
             <button class="export-btn" onclick="exportCSV()">ğŸ“Š åŒ¯å‡º (Excel)</button>
        </div>

        <span class="control-bar-label">ğŸ‘ï¸ é¡¯ç¤º/éš±è—</span>
        <div class="vis-bar">
            <div class="vis-btn active" onclick="toggleVis('jig',this)" title="æ²»å…·">Jig</div>
            <div class="vis-btn active" onclick="toggleVis('sample',this)" title="æ¨£å“">Sample</div>
            <div class="vis-btn active" onclick="toggleVis('blade',this)" title="åˆ€å…·">Blade</div>
            <div class="vis-btn active" onclick="toggleVis('nozzle',this)" title="å™´é ­">Nozzle</div>
            <div class="vis-btn active" onclick="toggleVis('anno',this)" title="æ¨™è¨»">Label</div>
        </div>

        <span class="control-bar-label">ğŸ¯ é¸æ“‡ç·¨è¼¯å°è±¡ (ç§»å‹•/èª¿æ•´)</span>
        <div class="vis-bar" style="background:#1a1a1a; border-color:#2979FF;">
            <div id="sel-nozzle" class="sel-btn active" onclick="selectActiveObj('nozzle')">Nozzle</div>
            <div id="sel-blade" class="sel-btn" onclick="selectActiveObj('blade')">Blade</div>
            <div id="sel-sample" class="sel-btn" onclick="selectActiveObj('sample')">Sample</div>
            <div id="sel-jig" class="sel-btn" onclick="selectActiveObj('jig')">Jig</div>
        </div>
    </div>

    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('dims')">ğŸ“ å°ºå¯¸</button>
        <button class="tab-btn" onclick="switchTab('trans')">ğŸ”„ è®Šæ›</button>
        <button class="tab-btn" onclick="switchTab('anno')">ğŸ“ æ¨™è¨»</button>
        <button class="tab-btn" onclick="switchTab('sim')">âš™ï¸ æ¨¡æ“¬</button>
    </div>

    <div id="tab-dims" class="tab-content active">
        <div id="dims-jig" class="group" style="display:none">
            <span class="group-title">
                æ²»å…·åƒæ•¸ 
                <input type="color" id="col_jig" value="#9C27B0" onchange="updateObjColor('jig', this.value)" title="æ›´æ”¹é¡è‰²">
            </span>
            <div class="row"><label>é«˜åº¦ H</label><input type="number" id="val_j_h" onchange="updateVal('j_h',this.value)"><input type="range" id="rng_j_h" min="1" max="100" step="0.1" oninput="updateVal('j_h',this.value)"></div>
            <div class="row"><label>è§’åº¦ A</label><input type="number" id="val_j_a" onchange="updateVal('j_a',this.value)"><input type="range" id="rng_j_a" min="5" max="89" step="1" oninput="updateVal('j_a',this.value)"></div>
            <div class="row"><label>æ·±åº¦ Z</label><input type="number" id="val_j_w" onchange="updateVal('j_w',this.value)"><input type="range" id="rng_j_w" min="1" max="100" step="0.1" oninput="updateVal('j_w',this.value)"></div>
        </div>
        <div id="dims-sample" class="group" style="display:none">
            <span class="group-title">
                æ¨£å“åƒæ•¸
                <input type="color" id="col_sample" value="#2196F3" onchange="updateObjColor('sample', this.value)" title="æ›´æ”¹é¡è‰²">
            </span>
            <div class="row"><label>é•·åº¦ L</label><input type="number" id="val_s_l" onchange="updateVal('s_l',this.value)"><input type="range" id="rng_s_l" min="1" max="100" step="0.1" oninput="updateVal('s_l',this.value)"></div>
            <div class="row" id="row-s-th"><label>åšåº¦ T</label><input type="number" id="val_s_th" onchange="updateVal('s_th',this.value)"><input type="range" id="rng_s_th" min="0.1" max="20" step="0.01" oninput="updateVal('s_th',this.value)"></div>
            <div class="row"><label>å¯¬åº¦ Z</label><input type="number" id="val_s_w" onchange="updateVal('s_w',this.value)"><input type="range" id="rng_s_w" min="1" max="100" step="0.1" oninput="updateVal('s_w',this.value)"></div>
            <div class="row"><label>æ»‘å‹• P</label><input type="number" id="val_s_t" onchange="updateVal('s_t',this.value)"><input type="range" id="rng_s_t" min="0" max="1" step="0.01" oninput="updateVal('s_t',this.value)"></div>
        </div>
        <div id="dims-blade" class="group" style="display:none">
            <span class="group-title">
                åˆ€å…·åƒæ•¸
                <input type="color" id="col_blade" value="#FFC107" onchange="updateObjColor('blade', this.value)" title="æ›´æ”¹é¡è‰²">
            </span>
            <div class="row"><label>åˆ€åš X</label><input type="number" id="val_b_t" onchange="updateVal('b_t',this.value)"><input type="range" id="rng_b_t" min="0.01" max="10" step="0.01" oninput="updateVal('b_t',this.value)"></div>
            <div class="row"><label>åˆ€å¯¬ Z</label><input type="number" id="val_b_w" onchange="updateVal('b_w',this.value)"><input type="range" id="rng_b_w" min="1" max="100" step="0.1" oninput="updateVal('b_w',this.value)"></div>
            <div class="row"><label>åˆ‡æ·± Y</label><input type="number" id="val_b_d" onchange="updateVal('b_d',this.value)"><input type="range" id="rng_b_d" min="0" max="100" step="0.1" oninput="updateVal('b_d',this.value)"></div>
        </div>
        <div id="dims-nozzle" class="group">
            <span class="group-title">
                å™´é ­åƒæ•¸
                <input type="color" id="col_nozzle" value="#9E9E9E" onchange="updateObjColor('nozzle', this.value)" title="æ›´æ”¹é¡è‰²">
            </span>
            <div style="font-size:12px;color:#888;">æ¨™æº–å™´é ­ï¼Œç„¡å°ºå¯¸è¨­å®šã€‚è«‹ä½¿ç”¨è®Šæ›å·¥å…·ç§»å‹•ã€‚</div>
        </div>
    </div>

    <div id="tab-trans" class="tab-content">
        <button id="btn-snap" class="action-btn" style="background:#FF9800; margin-bottom:10px;" onclick="toggleSnapMode()">ğŸ§² è¡¨é¢å¸é™„å°é½Š (Snap)</button>
        <div class="group">
            <span class="group-title" style="color:#00E676;">ä½ç½® (mm)</span>
            <div class="row"><label>X</label><input type="number" id="t_px" onchange="updateTransFromInput()"><input type="range" id="rg_px" min="-50" max="50" oninput="document.getElementById('t_px').value=this.value;updateTransFromInput()"></div>
            <div class="row"><label>Y</label><input type="number" id="t_py" onchange="updateTransFromInput()"><input type="range" id="rg_py" min="-50" max="50" oninput="document.getElementById('t_py').value=this.value;updateTransFromInput()"></div>
            <div class="row"><label>Z</label><input type="number" id="t_pz" onchange="updateTransFromInput()"><input type="range" id="rg_pz" min="-50" max="50" oninput="document.getElementById('t_pz').value=this.value;updateTransFromInput()"></div>
        </div>
        <div class="group">
            <span class="group-title" style="color:#FFC107;">æ—‹è½‰ (Â°)</span>
            <div class="row"><label>X</label><input type="number" id="t_rx" onchange="updateTransFromInput()"><input type="range" id="rg_rx" min="-180" max="180" oninput="document.getElementById('t_rx').value=this.value;updateTransFromInput()"></div>
            <div class="row"><label>Y</label><input type="number" id="t_ry" onchange="updateTransFromInput()"><input type="range" id="rg_ry" min="-180" max="180" oninput="document.getElementById('t_ry').value=this.value;updateTransFromInput()"></div>
            <div class="row"><label>Z</label><input type="number" id="t_rz" onchange="updateTransFromInput()"><input type="range" id="rg_rz" min="-180" max="180" oninput="document.getElementById('t_rz').value=this.value;updateTransFromInput()"></div>
        </div>
    </div>

    <div id="tab-anno" class="tab-content">
        <div class="group" style="border-left: 3px solid #E91E63;">
            <span class="group-title" style="color:#E91E63;">æ¨™è¨»å·¥å…· (Annotation)</span>
            <div class="row" style="gap:2px;">
                <button id="btn-anno-text" class="vis-btn" onclick="setAnnoMode('text')">ğŸ”¤ æ–‡å­—</button>
                <button id="btn-anno-line" class="vis-btn" onclick="setAnnoMode('line')">ğŸ“ æ‹‰ç·š</button>
                <button id="btn-anno-edge" class="vis-btn" onclick="setAnnoMode('edge')">ğŸ“ é‚Šç·£</button>
            </div>
            <div class="row">
                <button class="vis-btn" style="background:#444;" onclick="clearAnnotations()">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰</button>
                <button class="vis-btn" style="background:#444;" onclick="deleteLastAnnotation()">â†©ï¸ å¾©åŸ</button>
            </div>
        </div>

        <div class="group">
            <span class="group-title">æ¨£å¼è¨­å®š</span>
            <div class="row"><label>é€æ˜åº¦</label><input type="range" id="anno-opacity" min="0.1" max="1.0" step="0.1" value="0.7" oninput="updateAnnoStyle()"></div>
            <div class="row"><label>èƒŒæ™¯è‰²</label><input type="color" id="anno-bg-color" value="#000000" onchange="updateAnnoStyle()"> <input type="color" id="anno-text-color" value="#ffffff" onchange="updateAnnoStyle()" title="æ–‡å­—è‰²"></div>
            <div class="row"><label>ç·šæ¢è‰²</label><input type="color" id="anno-line-color" value="#E91E63" onchange="updateAnnoStyle()"></div>
            <div class="row"><label>ç·šæ¢ç²—ç´°</label><input type="range" id="anno-line-width" min="0.5" max="10" step="0.5" value="2" oninput="updateAnnoStyle()"></div>
            <div class="row"><label>å­—é«”å¤§å°</label><input type="range" id="anno-font-size" min="10" max="40" value="14" oninput="updateAnnoStyle()"></div>
        </div>
    </div>

    <div id="tab-sim" class="tab-content">
        <div class="group" style="border-left: 3px solid #00B0FF;">
            <span class="group-title" style="color:#00B0FF;">ğŸ’¦ å™´æ°´ç³»çµ±</span>
            <button id="btn-water" class="action-btn" style="background:#0277bd" onclick="toggleWater()">ON / OFF</button>
            <div class="row" style="margin-top:5px"><label>æ°´å£“</label><input type="range" id="w_pressure" min="0" max="200" value="80"></div>
            <div class="row"><label>æ“´æ•£</label><input type="range" id="w_spread" min="0" max="45" value="5" oninput="waterSpread=this.value"></div>
            <div class="row"><label>è¡æ“Šé¡¯ç¤º</label><select id="water-target" onchange="changeWaterTarget(this.value)" style="flex:1;background:#333;color:white;"><option value="none">ç„¡ (ç©¿é€)</option><option value="sample" selected>Sample (ç†±åŠ›åœ–)</option><option value="jig">Jig (ç†±åŠ›åœ–)</option></select></div>
        </div>

        <div class="group" style="border-left: 3px solid #FF9800;">
            <span class="group-title" style="color:#FF9800;">ğŸ¯ åˆ‡å‰² Boolean</span>
            <div class="row"><label>ç›®æ¨™</label><select id="target-select" onchange="updateModel()" style="flex:1;background:#333;color:white;"><option value="none">ä¸åˆ‡å‰²</option><option value="sample" selected>åˆ‡æ¨£å“</option><option value="jig">åˆ‡æ²»å…·</option></select></div>
            <button class="action-btn" style="background:#444" onclick="toggleWireframe()">åˆ‡æ›ç¶²æ ¼</button>
        </div>
    </div>
</div>

<div id="canvas-container"></div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';
    import { SUBTRACTION, Brush, Evaluator } from 'three-bvh-csg';
    import { initializeApp } from 'firebase-app';
    import { getFirestore, collection, addDoc, getDocs, doc, getDoc, deleteDoc, updateDoc, serverTimestamp, query, orderBy } from 'firebase-firestore';

    // --- Firebase Config ---
    const firebaseConfig = {
        apiKey: "AIzaSyCnHhksuhJs9RdrL7DPnsAvR21ZND7kIOI",
        authDomain: "stack-diagram-db.firebaseapp.com",
        projectId: "stack-diagram-db",
        storageBucket: "stack-diagram-db.firebasestorage.app",
        messagingSenderId: "67240747982",
        appId: "1:67240747982:web:1fb065e40e936a7485419f"
    };
    
    let db = null;
    try {
        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        console.log("ğŸ”¥ Firebase Initialized");
    } catch (e) { console.error("Firebase init failed", e); }

    // --- State & Defaults ---
    const defaultParams = {
        j_h: 5, j_a: 45, j_w: 20,
        s_t: 0.5, s_l: 10, s_th: 0.8, s_w: 15, s_r: 0,
        b_t: 0.5, b_w: 25, b_d: 3.0
    };
    const defaultTransforms = {
        jig: { px:0, py:0, pz:0, rx:0, ry:0, rz:0 },
        sample: { px:0, py:0, pz:0, rx:0, ry:0, rz:0 },
        blade: { px:0, py:20, pz:0, rx:0, ry:0, rz:0 },
        nozzle: { px:5, py:15, pz:0, rx:0, ry:0, rz:-0.78 }
    };

    let params = {...defaultParams};
    let transforms = JSON.parse(JSON.stringify(defaultTransforms));
    let currentObj = 'nozzle';
    let waterEnabled = false;
    let waterSpread = 5;
    let snapMode = false;
    
    // Annotation State
    let annoMode = null; 
    let annotations = []; // { type, pos, content, style, obj(Mesh), dom(HTML), offsetX, offsetY }
    let tempPoints = [];
    let hoveredEdgeMesh = null;
    
    // --- 3D Scene Setup ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x1a1a1a);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(35,35,45); camera.lookAt(0,0,0);
    const renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0x404040, 1.5));
    const dirLight = new THREE.DirectionalLight(0xffffff, 2); dirLight.position.set(20,50,20); 
    dirLight.castShadow=true; dirLight.shadow.mapSize.set(2048,2048); scene.add(dirLight);
    
    // Add Camera Light (Headlight) for Cylinders (Shiny effect)
    const camLight = new THREE.PointLight(0xffffff, 0.6);
    camera.add(camLight);
    scene.add(camera);

    scene.add(new THREE.GridHelper(200, 200, 0x333333, 0x222222));
    scene.add(new THREE.AxesHelper(5));

    const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping=true;
    const tControls = new TransformControls(camera, renderer.domElement);
    tControls.addEventListener('dragging-changed', e => controls.enabled = !e.value);
    tControls.addEventListener('change', () => {
        if(!tControls.object) return;
        const o=tControls.object; const k=currentObj;
        transforms[k].px=o.position.x; transforms[k].py=o.position.y; transforms[k].pz=o.position.z;
        transforms[k].rx=o.rotation.x; transforms[k].ry=o.rotation.y; transforms[k].rz=o.rotation.z;
        updateTransformUI();
        if(k!=='nozzle' && document.getElementById('target-select').value!=='none') updateModel(); 
    });
    scene.add(tControls);

    // Groups
    const jigGroup=new THREE.Group(); scene.add(jigGroup);
    const sampleGroup=new THREE.Group(); jigGroup.add(sampleGroup); 
    const bladeGroup=new THREE.Group(); scene.add(bladeGroup);
    const nozzleGroup=new THREE.Group(); scene.add(nozzleGroup);
    const annoGroup=new THREE.Group(); scene.add(annoGroup); 

    // Materials
    const matJig=new THREE.MeshStandardMaterial({color:0x9C27B0, roughness:0.3});
    const matSample=new THREE.MeshStandardMaterial({color:0x2196F3, roughness:0.2});
    const matBlade=new THREE.MeshStandardMaterial({color:0xFFC107, roughness:0.1, metalness:0.8});
    const matNozzle=new THREE.MeshStandardMaterial({color:0x9E9E9E});

    // Nozzle Model
    const nCyl = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,2), matNozzle); nCyl.position.y=1.5;
    const nCone = new THREE.Mesh(new THREE.ConeGeometry(0.5,1,32,1,true), matNozzle); nCone.rotation.x=Math.PI; nCone.position.y=0.5;
    const nozMesh = new THREE.Group(); nozMesh.add(nCyl,nCone); nozzleGroup.add(nozMesh);

    let brushJig, brushBlade, sampleBrushes=[], resultMesh, isWireframe=false;
    const evaluator = new Evaluator();

    // Heatmap
    const impactCanvas = document.getElementById('impact-canvas');
    const impactCtx = impactCanvas.getContext('2d');
    impactCtx.fillStyle = 'black'; impactCtx.fillRect(0, 0, 512, 512);
    const impactTexture = new THREE.CanvasTexture(impactCanvas);
    let impactTargetMesh = null;
    let originalMaterial = null;

    // Raycaster
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // --- Leader Line System (2D Canvas) ---
    const leaderCanvas = document.getElementById('leader-canvas');
    const leaderCtx = leaderCanvas.getContext('2d');
    
    function resizeLeaderCanvas() {
        leaderCanvas.width = window.innerWidth;
        leaderCanvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeLeaderCanvas);
    resizeLeaderCanvas();

    function drawLeaderLines() {
        leaderCtx.clearRect(0, 0, leaderCanvas.width, leaderCanvas.height);
        leaderCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        leaderCtx.lineWidth = 1.5;
        leaderCtx.beginPath();

        annotations.forEach(a => {
            if(a.dom && a.pos && (a.offsetX !== 0 || a.offsetY !== 0)) {
                // Calculate 3D point projected
                const tempV = a.pos.clone();
                tempV.project(camera);
                
                // If point is behind camera, ignore
                if(Math.abs(tempV.z) > 1) return;

                const originX = (tempV.x * .5 + .5) * leaderCanvas.width;
                const originY = (tempV.y * -.5 + .5) * leaderCanvas.height;

                // Div Center
                const rect = a.dom.getBoundingClientRect();
                const divX = rect.left + rect.width / 2;
                const divY = rect.top + rect.height / 2;

                leaderCtx.moveTo(originX, originY);
                leaderCtx.lineTo(divX, divY);
            }
        });
        leaderCtx.stroke();
    }

    // --- Export Functions ---
    window.exportImage = () => {
        renderer.render(scene, camera);
        const link = document.createElement('a');
        link.download = `cutting_3d_view_${new Date().toISOString().slice(0,19).replace(/:/g,"-")}.png`;
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();
    };

    window.exportCSV = () => {
        let csv = "Category,Parameter,Value\n";
        
        // Params
        for(let k in params) {
            csv += `Dimension,${k},${params[k]}\n`;
        }
        
        // Transforms
        for(let obj in transforms) {
            for(let axis in transforms[obj]) {
                csv += `Transform,${obj}_${axis},${transforms[obj][axis]}\n`;
            }
        }

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "cutting_3d_data.csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    // --- Object Color Change ---
    window.updateObjColor = (type, hexColor) => {
        let mat = null;
        if(type === 'jig') mat = matJig;
        if(type === 'sample') mat = matSample;
        if(type === 'blade') mat = matBlade;
        if(type === 'nozzle') mat = matNozzle;

        if(mat) {
            mat.color.set(hexColor);
            // Re-trigger update if needed (mostly for CSG results which might share material)
            updateModel();
        }
    };

    // --- Annotation Logic ---
    window.setAnnoMode = (mode) => {
        annoMode = (annoMode === mode) ? null : mode;
        document.querySelectorAll('#tab-anno .vis-btn').forEach(b=>b.classList.remove('active'));
        if(annoMode) document.getElementById('btn-anno-'+mode).classList.add('active');
        
        const hint = document.getElementById('snap-hint');
        if(annoMode) {
            hint.style.display = 'block';
            if(mode==='text') hint.innerText = "ğŸ”¤ é»æ“Šç‰©ä»¶è¡¨é¢æ–°å¢æ–‡å­—";
            if(mode==='line') hint.innerText = "ğŸ“ é»æ“Šå…©é»æ‹‰ç·š";
            if(mode==='edge') hint.innerText = "ğŸ“ ç§»å‹•åˆ°é‚Šç·£å¸é™„ (é»ƒè‰²é è¦½)ï¼Œé»æ“Šå›ºå®š";
            tControls.detach();
        } else {
            hint.style.display = 'none';
            if(hoveredEdgeMesh) { annoGroup.remove(hoveredEdgeMesh); hoveredEdgeMesh=null; }
            tempPoints = [];
            selectActiveObj(currentObj); // Restore gizmo
        }
    };

    window.updateAnnoStyle = () => {
        const thicknessScale = parseFloat(document.getElementById('anno-line-width').value) * 0.2;
        const color = document.getElementById('anno-line-color').value;
        const textColor = document.getElementById('anno-text-color').value;
        const bgColor = document.getElementById('anno-bg-color').value;
        const textSize = document.getElementById('anno-font-size').value;
        const opacity = parseFloat(document.getElementById('anno-opacity').value);

        annotations.forEach(a => {
            // Update 3D Lines (Scaling X and Y only)
            if((a.type === 'line' || a.type === 'edge') && a.obj) {
                // FIXED: Scale Thickness (X, Y) but keep Length (Z) intact (1)
                a.obj.scale.set(thicknessScale, thicknessScale, 1);
                a.obj.material.color.set(color);
                a.obj.material.opacity = opacity;
            }
            // Update Text
            if(a.dom) {
                a.dom.style.color = textColor;
                a.dom.style.fontSize = textSize + 'px';
                // Convert Hex to RGBA for background opacity
                const r = parseInt(bgColor.slice(1,3), 16), g = parseInt(bgColor.slice(3,5), 16), b = parseInt(bgColor.slice(5,7), 16);
                a.dom.style.backgroundColor = `rgba(${r},${g},${b},${opacity})`;
            }
        });
    };

    window.removeAnnotation = (annoObj) => {
        if(annoObj.obj) annoGroup.remove(annoObj.obj);
        if(annoObj.dom) annoObj.dom.remove();
        annotations = annotations.filter(a => a !== annoObj);
    };

    window.clearAnnotations = () => {
        if(!confirm("ç¢ºå®šæ¸…é™¤æ‰€æœ‰æ¨™è¨»?")) return;
        annotations.forEach(a => {
            if(a.obj) annoGroup.remove(a.obj);
            if(a.dom) a.dom.remove();
        });
        annotations = [];
        document.getElementById('label-container').innerHTML = '';
        leaderCtx.clearRect(0,0,leaderCanvas.width, leaderCanvas.height);
    };
    
    window.deleteLastAnnotation = () => {
        if(annotations.length === 0) return;
        const a = annotations.pop();
        if(a.obj) annoGroup.remove(a.obj);
        if(a.dom) a.dom.remove();
    }

    // Draggable Label Implementation
    let dragLabel = null;
    let dragStartPos = { x: 0, y: 0 };
    let dragStartOffset = { x: 0, y: 0 };

    function createTextLabel(pos, text = "Label", parentAnno = null) {
        const div = document.createElement('div');
        div.className = 'annotation-label';
        
        const color = document.getElementById('anno-text-color').value;
        const bgColor = document.getElementById('anno-bg-color').value;
        const size = document.getElementById('anno-font-size').value;
        const opacity = parseFloat(document.getElementById('anno-opacity').value);
        
        div.style.color = color;
        // RGBA for background
        const r = parseInt(bgColor.slice(1,3), 16), g = parseInt(bgColor.slice(3,5), 16), b = parseInt(bgColor.slice(5,7), 16);
        div.style.backgroundColor = `rgba(${r},${g},${b},${opacity})`;
        
        div.style.fontSize = size + 'px';
        
        const input = document.createElement('input');
        input.value = text;
        
        const closeBtn = document.createElement('button');
        closeBtn.className = 'close-btn';
        closeBtn.innerHTML = 'Ã—';
        closeBtn.onclick = (e) => {
            e.stopPropagation(); 
            if(parentAnno) window.removeAnnotation(parentAnno);
            else {
                const self = annotations.find(a => a.dom === div);
                if(self) window.removeAnnotation(self);
            }
        };

        div.addEventListener('mousedown', (e) => {
            if(e.target === input || e.target === closeBtn) return;
            e.preventDefault();
            dragLabel = parentAnno || annotations.find(a => a.dom === div);
            if(dragLabel) {
                dragStartPos = { x: e.clientX, y: e.clientY };
                dragStartOffset = { x: dragLabel.offsetX || 0, y: dragLabel.offsetY || 0 };
                div.style.cursor = 'grabbing';
            }
        });

        div.appendChild(input);
        div.appendChild(closeBtn);
        document.getElementById('label-container').appendChild(div);
        
        if(!parentAnno) {
            const annoData = {
                type: 'text',
                pos: pos.clone(),
                dom: div,
                offsetX: 0, offsetY: 0
            };
            annotations.push(annoData);
        }
        
        updateLabels();
        return div;
    }
    
    window.addEventListener('mousemove', (e) => {
        if(dragLabel) {
            const dx = e.clientX - dragStartPos.x;
            const dy = e.clientY - dragStartPos.y;
            dragLabel.offsetX = dragStartOffset.x + dx;
            dragLabel.offsetY = dragStartOffset.y + dy;
            updateLabels();
        }
    });
    
    window.addEventListener('mouseup', () => {
        if(dragLabel && dragLabel.dom) dragLabel.dom.style.cursor = 'move';
        dragLabel = null;
    });

    // Helper: Create Cylinder from P1 to P2
    // CORRECTED: Scale only X/Y for thickness, preserve Length
    function createCylinderLine(p1, p2, color, scaleFactor) {
        const vec = new THREE.Vector3().subVectors(p2, p1);
        const len = vec.length();
        
        // Geometry oriented along Z-axis
        const geo = new THREE.CylinderGeometry(1, 1, len, 32);
        geo.translate(0, len / 2, 0);
        geo.rotateX(Math.PI / 2); // Now it lies on Z axis
        
        const opacity = parseFloat(document.getElementById('anno-opacity').value);
        const mat = new THREE.MeshPhongMaterial({ 
            color: color,
            transparent: true,
            opacity: opacity, 
            depthTest: false, // ALWAYS ON TOP
            shininess: 100
        });
        
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(p1);
        mesh.lookAt(p2);
        
        mesh.renderOrder = 999;
        // Scale X and Y (Diameter), Z (Length) stays 1
        mesh.scale.set(scaleFactor, scaleFactor, 1);
        return mesh;
    }

    function createLine3D(p1, p2) {
        const color = document.getElementById('anno-line-color').value;
        const thickness = parseFloat(document.getElementById('anno-line-width').value) * 0.2; 
        
        const cylinderLine = createCylinderLine(p1, p2, color, thickness);
        annoGroup.add(cylinderLine);
        
        const annoData = { type: 'line', obj: cylinderLine, offsetX: 0, offsetY: 0 };
        annotations.push(annoData);
        
        const mid = p1.clone().add(p2).multiplyScalar(0.5);
        const dist = p1.distanceTo(p2).toFixed(1) + "mm";
        annoData.dom = createTextLabel(mid, dist, annoData); 
        annoData.pos = mid; 
    }

    function highlightEdge(mesh, faceIndex, point) {
        if(!mesh.geometry) return;
        
        const geo = mesh.geometry;
        const pos = geo.attributes.position;
        const idx = geo.index ? geo.index.array : null;

        const getV = (i) => new THREE.Vector3().fromBufferAttribute(pos, i).applyMatrix4(mesh.matrixWorld);
        let vA, vB, vC;

        if (idx) {
            vA = getV(idx[faceIndex * 3]);
            vB = getV(idx[faceIndex * 3 + 1]);
            vC = getV(idx[faceIndex * 3 + 2]);
        } else {
            vA = getV(faceIndex * 3);
            vB = getV(faceIndex * 3 + 1);
            vC = getV(faceIndex * 3 + 2);
        }

        const lineAB = new THREE.Line3(vA, vB), lineBC = new THREE.Line3(vB, vC), lineCA = new THREE.Line3(vC, vA);
        const dAB = lineAB.closestPointToPoint(point, true).distanceTo(point);
        const dBC = lineBC.closestPointToPoint(point, true).distanceTo(point);
        const dCA = lineCA.closestPointToPoint(point, true).distanceTo(point);

        let p1, p2;
        if(dAB <= dBC && dAB <= dCA) { p1=vA; p2=vB; }
        else if(dBC <= dAB && dBC <= dCA) { p1=vB; p2=vC; }
        else { p1=vC; p2=vA; }

        if(hoveredEdgeMesh) annoGroup.remove(hoveredEdgeMesh);
        
        // Preview: Very Thick (1.0), Yellow, Opacity 0.6
        hoveredEdgeMesh = createCylinderLine(p1, p2, 0xFFFF00, 1.0); 
        annoGroup.add(hoveredEdgeMesh);
        
        return [p1, p2];
    }

    // --- Interaction ---
    container.addEventListener('mousedown', (e) => {
        if(e.button !== 0) return;
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        if(annoMode) {
            raycaster.setFromCamera(mouse, camera);
            // FIXED: Ignore annoGroup during detection so we hit the real object
            const objectsToIntersect = [jigGroup, sampleGroup, bladeGroup, resultMesh].filter(x=>x);
            const intersects = raycaster.intersectObjects(objectsToIntersect, true);
            const hit = intersects.find(i => i.object.visible && i.object.type === 'Mesh');
            
            if(hit) {
                if(annoMode === 'text') {
                    createTextLabel(hit.point, "Text");
                    setAnnoMode(null); 
                } else if(annoMode === 'line') {
                    tempPoints.push(hit.point);
                    if(tempPoints.length === 2) {
                        createLine3D(tempPoints[0], tempPoints[1]);
                        tempPoints = [];
                        setAnnoMode(null);
                    }
                } else if(annoMode === 'edge') {
                    // Because we clicked the object behind the preview, hoveredEdgeMesh exists
                    if(hoveredEdgeMesh) {
                        const color = document.getElementById('anno-line-color').value;
                        const thickness = parseFloat(document.getElementById('anno-line-width').value) * 0.2;
                        const opacity = parseFloat(document.getElementById('anno-opacity').value);
                        
                        // Convert preview to real annotation
                        const finalMesh = hoveredEdgeMesh.clone();
                        finalMesh.material = hoveredEdgeMesh.material.clone();
                        finalMesh.material.color.set(color);
                        finalMesh.material.opacity = opacity;
                        finalMesh.scale.set(thickness, thickness, 1);
                        
                        annoGroup.add(finalMesh);
                        const annoData = { type: 'edge', obj: finalMesh, offsetX: 0, offsetY: 0 };
                        annotations.push(annoData);

                        const len = finalMesh.geometry.parameters.height; 
                        annoData.dom = createTextLabel(hit.point, len.toFixed(1) + "mm", annoData);
                        annoData.pos = hit.point;

                        annoGroup.remove(hoveredEdgeMesh); hoveredEdgeMesh = null;
                        setAnnoMode(null);
                    }
                }
            }
        }
    });

    container.addEventListener('mousemove', (e) => {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        if(annoMode === 'edge') {
            raycaster.setFromCamera(mouse, camera);
            // FIXED: Ignore AnnoGroup so we can 'see through' the yellow preview line
            const objectsToIntersect = [jigGroup, sampleGroup, bladeGroup, resultMesh].filter(x=>x);
            const intersects = raycaster.intersectObjects(objectsToIntersect, true);
            const hit = intersects.find(i => i.object.visible && i.object.type === 'Mesh');
            
            if(hit) {
                highlightEdge(hit.object, hit.faceIndex, hit.point);
            } else {
                if(hoveredEdgeMesh) { annoGroup.remove(hoveredEdgeMesh); hoveredEdgeMesh = null; }
            }
        }
    });

    function updateLabels() {
        annotations.forEach(a => {
            if(a.dom && a.pos) {
                const tempV = a.pos.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * container.clientWidth;
                const y = (tempV.y * -.5 + .5) * container.clientHeight;
                
                if(Math.abs(tempV.z) > 1) { 
                     a.dom.style.display = 'none';
                } else {
                    a.dom.style.display = 'flex';
                    const finalX = x + (a.offsetX || 0);
                    const finalY = y + (a.offsetY || 0);
                    a.dom.style.left = finalX + 'px';
                    a.dom.style.top = finalY + 'px';
                }
            }
        });
        drawLeaderLines();
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateLabels();
    });

    // --- Object Selection ---
    window.selectActiveObj = (val) => {
        currentObj = val;
        document.querySelectorAll('.sel-btn').forEach(b => b.classList.remove('active'));
        document.getElementById('sel-' + val).classList.add('active');
        
        tControls.detach();
        if(val==='jig') tControls.attach(jigGroup);
        if(val==='sample') tControls.attach(sampleGroup);
        if(val==='blade') tControls.attach(bladeGroup);
        if(val==='nozzle') tControls.attach(nozzleGroup);
        
        ['jig','sample','blade','nozzle'].forEach(k => { 
            const el = document.getElementById('dims-'+k); 
            if(el) el.style.display = (k===val ? 'block' : 'none'); 
        });
        updateTransformUI();
    };

    // --- Main Logic ---
    window.initFromDefault = async () => {
        const defId = localStorage.getItem('cutting3d_def_id');
        if(defId && db) {
           try {
               const docSnap = await getDoc(doc(db, "projects_v6", defId));
               if(docSnap.exists()) {
                   loadProjectData(docSnap.data());
                   return;
               }
           } catch(e) { console.warn("Default load failed"); }
        }
        params = {...defaultParams};
        transforms = JSON.parse(JSON.stringify(defaultTransforms));
        updateAllUI();
        clearAnnotations();
    };

    window.openSaveModal = () => {
        if(!db) return alert("è³‡æ–™åº«æœªé€£ç·š");
        renderer.render(scene, camera);
        const url = renderer.domElement.toDataURL('image/jpeg', 0.5);
        document.getElementById('save-preview-img').src = url;
        document.getElementById('save-name').value = "Project " + new Date().toLocaleDateString();
        document.getElementById('modal-save').style.display = 'flex';
    };

    window.confirmSave = async () => {
        const name = document.getElementById('save-name').value;
        const desc = document.getElementById('save-desc').value;
        const thumb = document.getElementById('save-preview-img').src;
        
        const serialAnno = annotations.map(a => {
            if(a.type === 'text') {
                 return { type: 'text', pos: a.pos, text: a.dom.querySelector('input').value, 
                          offsetX: a.offsetX, offsetY: a.offsetY,
                          style: { color: a.dom.style.color, bg: a.dom.style.backgroundColor, size: a.dom.style.fontSize }};
            }
            return null; 
        }).filter(x => x);

        const data = {
            name, desc, thumb,
            params, transforms,
            annotations: serialAnno,
            timestamp: serverTimestamp()
        };

        try {
            await addDoc(collection(db, "projects_v6"), data);
            alert("å„²å­˜æˆåŠŸ");
            document.getElementById('modal-save').style.display = 'none';
        } catch(e) { alert("å„²å­˜å¤±æ•—: " + e.message); }
    };

    let allProjects = [];
    window.openLoadModal = async () => {
        if(!db) return alert("è³‡æ–™åº«æœªé€£ç·š");
        document.getElementById('modal-load').style.display = 'flex';
        const list = document.getElementById('project-list');
        list.innerHTML = '<div style="text-align:center;padding:20px;">è¼‰å…¥ä¸­...</div>';
        try {
            const q = query(collection(db, "projects_v6"), orderBy("timestamp", "desc"));
            const snapshot = await getDocs(q);
            allProjects = [];
            snapshot.forEach(d => allProjects.push({id: d.id, ...d.data()}));
            filterProjects();
        } catch(e) { list.innerHTML = 'è¼‰å…¥å¤±æ•—'; }
    };

    window.filterProjects = () => {
        const filter = document.getElementById('search-proj').value.toLowerCase();
        const list = document.getElementById('project-list');
        list.innerHTML = '';
        const defId = localStorage.getItem('cutting3d_def_id');
        
        allProjects.forEach(p => {
            if(p.name.toLowerCase().includes(filter)) {
                const isDef = (p.id === defId);
                const dateStr = p.timestamp ? new Date(p.timestamp.toDate()).toLocaleString() : '';
                const div = document.createElement('div'); div.className = 'project-card';
                div.innerHTML = `
                    <div class="default-badge ${isDef?'':'inactive'}" onclick="setDefault('${p.id}', event)" title="è¨­ç‚ºé è¨­">â˜…</div>
                    <img src="${p.thumb}" class="project-thumb" onclick="loadProjectById('${p.id}')">
                    <div class="project-info">
                        <input type="text" value="${p.name}" onchange="renameProject('${p.id}', this.value)" style="width:100%; font-weight:bold; border:none; background:transparent; padding:0;">
                        <div style="font-size:11px;color:#aaa">${dateStr}</div>
                        <div style="font-size:11px;color:#888">${p.desc||''}</div>
                    </div>
                    <button class="tool-btn" style="background:#c62828" onclick="deleteProject('${p.id}')">ğŸ—‘ï¸</button>
                    <button class="tool-btn" style="background:#1565C0" onclick="loadProjectById('${p.id}')">è¼‰å…¥</button>
                `;
                list.appendChild(div);
            }
        });
    };
    
    window.setDefault = (id, e) => {
        e.stopPropagation();
        const curr = localStorage.getItem('cutting3d_def_id');
        localStorage.setItem('cutting3d_def_id', curr === id ? '' : id);
        filterProjects();
    };
    
    window.renameProject = async (id, newName) => { try { await updateDoc(doc(db, "projects_v6", id), { name: newName }); } catch(e){} };
    window.deleteProject = async (id) => { if(!confirm("ç¢ºå®šåˆªé™¤?")) return; try { await deleteDoc(doc(db, "projects_v6", id)); allProjects = allProjects.filter(p => p.id !== id); filterProjects(); } catch(e){} };
    
    window.loadProjectById = (id) => { const p = allProjects.find(x => x.id === id); if(p) loadProjectData(p); };
    
    function loadProjectData(data) {
        params = data.params;
        transforms = data.transforms;
        clearAnnotations();
        if(data.annotations) {
            data.annotations.forEach(a => {
                if(a.type === 'text') {
                    document.getElementById('anno-text-color').value = a.style.color;
                    document.getElementById('anno-bg-color').value = a.style.bg;
                    document.getElementById('anno-font-size').value = parseInt(a.style.size);
                    const pos = new THREE.Vector3(a.pos.x, a.pos.y, a.pos.z);
                    const dom = createTextLabel(pos, a.text);
                    // restore offsets
                    const anno = annotations[annotations.length-1];
                    anno.offsetX = a.offsetX || 0;
                    anno.offsetY = a.offsetY || 0;
                }
            });
        }
        updateAllUI();
        document.getElementById('modal-load').style.display='none';
    }

    function updateAllUI() {
        Object.keys(params).forEach(k => {
            const e1=document.getElementById('val_'+k), e2=document.getElementById('rng_'+k);
            if(e1) e1.value=params[k]; if(e2) e2.value=params[k];
        });
        updateTransformUI();
        updateModel();
        applyTransforms();
    }
    
    window.switchTab = (tab) => {
        document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active'));
        document.querySelector(`.tab-btn[onclick="switchTab('${tab}')"]`).classList.add('active');
        document.getElementById(`tab-${tab}`).classList.add('active');
    };
    
    // replaced by selectActiveObj
    window.changeSelection = (val) => { selectActiveObj(val); };
    
    window.updateVal = (key, val) => { params[key]=parseFloat(val); document.getElementById(`val_${key}`).value=val; document.getElementById(`rng_${key}`).value=val; updateModel(); };
    
    function updateTransformUI() {
        const t=transforms[currentObj];
        document.getElementById('t_px').value=t.px.toFixed(2); document.getElementById('rg_px').value=t.px;
        document.getElementById('t_py').value=t.py.toFixed(2); document.getElementById('rg_py').value=t.py;
        document.getElementById('t_pz').value=t.pz.toFixed(2); document.getElementById('rg_pz').value=t.pz;
        const dx=t.rx*180/Math.PI, dy=t.ry*180/Math.PI, dz=t.rz*180/Math.PI;
        document.getElementById('t_rx').value=dx.toFixed(1); document.getElementById('rg_rx').value=dx;
        document.getElementById('t_ry').value=dy.toFixed(1); document.getElementById('rg_ry').value=dy;
        document.getElementById('t_rz').value=dz.toFixed(1); document.getElementById('rg_rz').value=dz;
    }
    window.updateTransFromInput = () => {
        const t=transforms[currentObj];
        t.px=parseFloat(document.getElementById('t_px').value); t.py=parseFloat(document.getElementById('t_py').value); t.pz=parseFloat(document.getElementById('t_pz').value);
        t.rx=parseFloat(document.getElementById('t_rx').value)*Math.PI/180; t.ry=parseFloat(document.getElementById('t_ry').value)*Math.PI/180; t.rz=parseFloat(document.getElementById('t_rz').value)*Math.PI/180;
        applyTransforms();
    };
    window.toggleVis = (name, btn) => {
        let grp = null;
        if(name==='jig') grp=jigGroup; if(name==='sample') grp=sampleGroup;
        if(name==='blade') grp=bladeGroup; if(name==='nozzle') grp=nozzleGroup;
        if(name==='anno') { annoGroup.visible = !annoGroup.visible; document.getElementById('label-container').style.display = annoGroup.visible ? 'block' : 'none'; btn.classList.toggle('active'); return; }
        if(grp) { grp.visible = !grp.visible; btn.classList.toggle('active'); }
    };

    function applyTransforms() {
        const setT = (grp, t) => { grp.position.set(t.px, t.py, t.pz); grp.rotation.set(t.rx*Math.PI/180, t.ry*Math.PI/180, t.rz*Math.PI/180); grp.updateMatrixWorld(); }
        setT(jigGroup, transforms.jig); setT(sampleGroup, transforms.sample); setT(bladeGroup, transforms.blade); setT(nozzleGroup, transforms.nozzle);
    }
    
    function createJigGeometry() {
        const h=params.j_h, w=params.j_w, angleRad=params.j_a*Math.PI/180;
        const base=(params.j_a>=89)?0.1:h/Math.tan(angleRad);
        const s=new THREE.Shape(); s.moveTo(0,0); s.lineTo(base,0); s.lineTo(0,h); s.lineTo(0,0);
        const g=new THREE.ExtrudeGeometry(s,{steps:1,depth:w,bevelEnabled:false}); g.center(); g.translate(0,h/2,0);
        return {geo:g, base, h};
    }
    function updateModel() {
        if(brushJig) brushJig.geometry.dispose(); if(brushBlade) brushBlade.geometry.dispose();
        sampleBrushes.forEach(b=>b.geometry.dispose()); sampleBrushes=[];
        if(resultMesh) { scene.remove(resultMesh); resultMesh.geometry.dispose(); }
        
        jigGroup.clear(); sampleGroup.clear(); bladeGroup.clear();
        jigGroup.add(sampleGroup); 

        const jData = createJigGeometry();
        brushJig = new Brush(jData.geo, matJig); jigGroup.add(brushJig);

        const dx=jData.base, dy=-jData.h; const slopeLen=Math.sqrt(dx*dx+dy*dy);
        const ux=dx/slopeLen, uy=dy/slopeLen; const nx=-uy, ny=ux; 
        const topX=-jData.base/2, topY=jData.h/2;
        const slideDist = params.s_t * slopeLen;
        const baseSx=topX+ux*slideDist, baseSy=topY+uy*slideDist;
        const angleRad=params.j_a*Math.PI/180;

        const g = new THREE.BoxGeometry(params.s_l, params.s_th, params.s_w);
        const b = new Brush(g, matSample);
        b.rotation.set(0,0,0); b.rotateZ(-angleRad);
        const sx = baseSx + nx*(params.s_th/2) + ux*(params.s_l/2);
        const sy = baseSy + ny*(params.s_th/2) + uy*(params.s_l/2);
        b.position.set(sx, sy, 0); b.updateMatrixWorld();
        sampleBrushes.push(b); sampleGroup.add(b);

        applyTransforms();

        const gBlade = new THREE.BoxGeometry(params.b_t, 50, params.b_w); gBlade.translate(0, 25, 0); 
        brushBlade = new Brush(gBlade, matBlade); bladeGroup.add(brushBlade);

        const target = document.getElementById('target-select').value;
        jigGroup.updateMatrixWorld(true); sampleGroup.updateMatrixWorld(true); bladeGroup.updateMatrixWorld(true);

        if(target!=='none') {
            const worldBlade = brushBlade.clone(); worldBlade.applyMatrix4(bladeGroup.matrixWorld); worldBlade.material = matBlade;
            if(target==='jig') {
                brushJig.visible=false; 
                const wJig=brushJig.clone(); wJig.applyMatrix4(jigGroup.matrixWorld);
                const res=evaluator.evaluate(wJig, worldBlade, SUBTRACTION);
                res.material=matJig; res.castShadow=true; res.receiveShadow=true; scene.add(res); resultMesh=res;
            } else {
                sampleBrushes.forEach(b=>{
                    b.visible=false; 
                    const wb=b.clone(); wb.applyMatrix4(sampleGroup.matrix); wb.applyMatrix4(jigGroup.matrixWorld);
                    const res=evaluator.evaluate(wb, worldBlade, SUBTRACTION);
                    res.material=matSample; res.castShadow=true; res.receiveShadow=true; scene.add(res); resultMesh=res;
                });
            }
            const ghost = brushBlade.clone(); ghost.material = new THREE.MeshBasicMaterial({color:0xFFEB3B, wireframe:true, opacity:0.3, transparent:true});
            bladeGroup.add(ghost); brushBlade.visible=false;
        }
        updateWireframe();
        
        const wTilde = document.getElementById('water-target').value;
        if(wTilde === 'sample' || wTilde === 'jig') changeWaterTarget(wTilde);
    }
    
    window.toggleWireframe = () => { isWireframe=!isWireframe; updateWireframe(); };
    function updateWireframe() { scene.traverse(o => { if(o.isMesh && o.material && o.visible && o.name!=='ghost') o.material.wireframe=isWireframe; }); }
    window.setView = (v) => {
        const d=60; 
        if(v==='top') camera.position.set(0,d,0); if(v==='front') camera.position.set(0,0,d);
        if(v==='side') camera.position.set(d,0,0); if(v==='iso') camera.position.set(30,30,40);
        camera.lookAt(0,0,0); controls.target.set(0,0,0);
    };
    window.setGizmoMode = (m) => { tControls.setMode(m); document.querySelectorAll('.gizmo-btn').forEach(b=>b.classList.remove('active')); document.getElementById('mode-'+m).classList.add('active'); };
    window.setGizmoAxis = (a) => { tControls.showX=!a||a==='X'; tControls.showY=!a||a==='Y'; tControls.showZ=!a||a==='Z'; };

    const particleCount=2000, waterGeo=new THREE.BufferGeometry(), waterPos=new Float32Array(particleCount*3), waterVel=[];
    for(let i=0;i<particleCount;i++){waterPos[i*3+1]=-999;waterVel.push({x:0,y:0,z:0});}
    waterGeo.setAttribute('position',new THREE.BufferAttribute(waterPos,3));
    const waterMat=new THREE.PointsMaterial({color:0x00FFFF,size:0.2,transparent:true,opacity:0.8,depthWrite:false});
    const waterSystem=new THREE.Points(waterGeo, waterMat);
    waterSystem.frustumCulled = false; scene.add(waterSystem);

    window.toggleWater = () => { waterEnabled=!waterEnabled; waterSystem.visible=waterEnabled; };
    window.changeWaterTarget = (val) => {
        if(impactTargetMesh && originalMaterial) impactTargetMesh.material = originalMaterial;
        impactTargetMesh = null; originalMaterial = null;
        impactCtx.fillStyle = 'black'; impactCtx.fillRect(0,0,512,512); impactTexture.needsUpdate=true;
        
        let targetGroup = (val==='sample') ? sampleGroup : (val==='jig') ? jigGroup : null;
        if(targetGroup) {
             targetGroup.traverse(c => {
                 if(!impactTargetMesh && c.isMesh && c.material) {
                     impactTargetMesh = c; originalMaterial = c.material;
                     const newMat = c.material.clone(); newMat.emissiveMap = impactTexture;
                     newMat.emissive = new THREE.Color(0xffffff); newMat.emissiveIntensity=1.0;
                     c.material = newMat;
                 }
             });
        }
    };
    window.toggleSnapMode = () => {
        snapMode = !snapMode;
        const btn = document.getElementById('btn-snap');
        btn.style.background = snapMode ? '#00E676' : '#FF9800';
        if(snapMode) alert("æç¤ºï¼šè«‹ä½¿ç”¨ã€Œæ¨™è¨»->é‚Šç·£ã€åŠŸèƒ½é€²è¡Œé«˜ç²¾åº¦é‚Šç·£å¸é™„");
    };

    function animateWater() {
        if(!waterEnabled) return;
        impactCtx.fillStyle = 'rgba(0,0,0,0.1)'; impactCtx.fillRect(0,0,512,512); impactTexture.needsUpdate=true;
        const pressure = document.getElementById('w_pressure').value;
        const tipWorld = new THREE.Vector3(0,0,0).applyMatrix4(nozzleGroup.children[0].matrixWorld);
        const dirWorld = new THREE.Vector3(0,-1,0).transformDirection(nozzleGroup.matrixWorld).normalize();

        for(let i=0; i<particleCount; i++) {
             if(waterPos[i*3+1] < -20 || Math.random()<0.005) {
                waterPos[i*3] = tipWorld.x; waterPos[i*3+1] = tipWorld.y; waterPos[i*3+2] = tipWorld.z;
                const spd = 0.5 + (pressure/100)*1.0;
                const spreadRad = (waterSpread||5) * Math.PI / 180;
                const vel = dirWorld.clone().applyEuler(new THREE.Euler((Math.random()-.5)*spreadRad, 0, (Math.random()-.5)*spreadRad)).multiplyScalar(spd);
                waterVel[i] = vel;
             } else {
                 waterPos[i*3]+=waterVel[i].x; waterPos[i*3+1]+=waterVel[i].y; waterPos[i*3+2]+=waterVel[i].z;
                 if(impactTargetMesh) {
                     const p = new THREE.Vector3(waterPos[i*3], waterPos[i*3+1], waterPos[i*3+2]);
                     const box = new THREE.Box3().setFromObject(impactTargetMesh);
                     if(box.containsPoint(p)) {
                         const uvX = (p.x - box.min.x)/(box.max.x-box.min.x)*512;
                         const uvY = (p.z - box.min.z)/(box.max.z-box.min.z)*512; 
                         const r = 5 + (pressure/200)*10;
                         const grad = impactCtx.createRadialGradient(uvX,uvY,0,uvX,uvY,r);
                         grad.addColorStop(0,'white'); grad.addColorStop(1,'rgba(255,0,0,0)');
                         impactCtx.fillStyle = grad; impactCtx.beginPath(); impactCtx.arc(uvX,uvY,r,0,Math.PI*2); impactCtx.fill();
                         waterPos[i*3+1] = -999; 
                     }
                 }
             }
        }
        waterGeo.attributes.position.needsUpdate = true;
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        animateWater();
        updateLabels();
        renderer.render(scene, camera);
    }
    
    document.getElementById('loader').style.display='none';
    selectActiveObj('nozzle');
    initFromDefault();
    animate();

</script>
</body>
</html>
