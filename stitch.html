<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šåœ–é€£çºŒæ‹¼æ¥å·¥ä½œç«™</title>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        /* --- åŸºç¤ä½ˆå±€ --- */
        body {
            font-family: "Microsoft JhengHei", Arial, sans-serif;
            background-color: #121212;
            color: #ddd;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* å·¦å´ï¼šæ§åˆ¶é¢æ¿ */
        #left-panel {
            width: 280px;
            min-width: 200px;
            background-color: #1e1e1e;
            padding: 15px;
            padding-top: 60px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.3);
            z-index: 10;
        }

        /* ä¸­é–“ï¼šç•«å¸ƒå€ */
        #main-area {
            flex-grow: 1;
            background-color: #222;
            background-image: linear-gradient(#333 1px, transparent 1px), linear-gradient(90deg, #333 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* å³å´ï¼šåœ–ç‰‡ä½‡åˆ— */
        #right-panel {
            width: 300px;
            min-width: 200px;
            background-color: #1a1a1a;
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        /* å³å´æ¨™é¡Œå€ */
        .panel-header {
            padding: 10px 15px;
            background: #252525;
            border-bottom: 1px solid #333;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-actions {
            display: flex;
            gap: 5px;
        }

        /* åœ–ç‰‡åˆ—è¡¨å®¹å™¨ */
        #image-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* åœ–ç‰‡å¡ç‰‡æ¨£å¼ */
        .img-card {
            background: #333;
            border-radius: 6px;
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: grab;
            border: 2px solid transparent;
            transition: 0.2s;
        }
        .img-card:hover { background: #444; }
        .img-card.dragging { opacity: 0.5; border: 2px dashed #888; }
        
        /* æ¨™ç¤ºç›®å‰æ­£åœ¨ä½¿ç”¨çš„åœ–ç‰‡ */
        .img-card.is-base { border-color: #2196F3; background: #192c3d; } /* è—è‰²ï¼šåº•åœ– */
        .img-card.is-active { border-color: #FFC107; background: #3d3419; } /* é»ƒè‰²ï¼šä¸Šå±¤åœ– */

        .thumb {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 4px;
            background: #000;
        }

        .card-info {
            flex-grow: 1;
            overflow: hidden;
        }
        .filename {
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #fff;
        }
        .role-tag {
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 3px;
            margin-top: 4px;
            display: inline-block;
        }

        /* åˆªé™¤æŒ‰éˆ• */
        .btn-del {
            color: #666;
            cursor: pointer;
            padding: 4px;
            font-size: 16px;
        }
        .btn-del:hover { color: #ff5252; }

        /* --- ä¸€èˆ¬ UI å…ƒä»¶ --- */
        h2 { margin: 0 0 5px 0; color: #FFB74D; font-size: 18px; }
        button {
            padding: 10px;
            font-size: 14px;
            cursor: pointer;
            background-color: #444;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            width: 100%;
            transition: 0.2s;
            margin-bottom: 5px;
        }
        button:hover { background-color: #666; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* å°æŒ‰éˆ•æ¨£å¼ */
        .btn-sm {
            width: auto; 
            padding: 5px 10px; 
            margin:0; 
            font-size: 12px;
        }
        .btn-danger-sm { background-color: #c62828; border-color: #b71c1c; }
        .btn-danger-sm:hover { background-color: #d32f2f; }


        .btn-primary { background-color: #1976D2; border-color: #1565C0; font-weight: bold; }
        .btn-success { background-color: #43A047; border-color: #2E7D32; font-weight: bold; }
        .btn-auto { background-color: #7B1FA2; border-color: #4A148C; color: white; }
        
        #multi-file-input { display: none; }

        /* å›é¦–é æŒ‰éˆ• */
        .home-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            text-decoration: none;
            background: #444;
            padding: 6px 12px;
            border-radius: 20px;
            color: #fff;
            font-size: 12px;
            border: 1px solid #666;
            z-index: 100;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }

        #analysis-report {
            font-size: 12px; color: #81D4FA; background: #263238;
            padding: 10px; border-radius: 4px; border-left: 3px solid #0288D1;
            display: none; margin-top: 10px; line-height: 1.5;
        }
    </style>
</head>
<body>

    <a href="index.html" class="home-btn">ğŸ  å›é¦–é </a>

    <div id="left-panel">
        <h2>ğŸ§© æ§åˆ¶å°</h2>
        
        <div style="font-size:12px; color:#aaa; margin-bottom:10px;">
            OpenCV: <span id="cv-status" style="color:yellow">è¼‰å…¥ä¸­...</span>
        </div>

        <label>é€æ˜åº¦ (æª¢æŸ¥å°é½Š)</label>
        <input type="range" id="alphaSlider" min="0" max="1" step="0.05" value="0.6" oninput="draw()">

        <div style="height: 10px;"></div>

        <button id="btnAuto" class="btn-auto" onclick="runAutoStitch()" disabled>ğŸª„ AI è‡ªå‹•å¸é™„ (ç›®å‰ä½ç½®)</button>
        <div id="analysis-report"></div>

        <div style="height: 10px;"></div>

        <label>éµç›¤å¾®èª¿</label>
        <div style="display: flex; gap: 5px;">
            <button onclick="nudge(-1, 0)">â¬…ï¸</button>
            <button onclick="nudge(0, -1)">â¬†ï¸</button>
            <button onclick="nudge(0, 1)">â¬‡ï¸</button>
            <button onclick="nudge(1, 0)">â¡ï¸</button>
        </div>
        <div style="text-align: center; font-size: 12px; color: #888;">
            X: <span id="valX">0</span>, Y: <span id="valY">0</span>
        </div>

        <div style="margin-top: auto;"></div>

        <button class="btn-success" onclick="mergeAndNext()">âœ… åˆä½µä¸¦æ›ä¸‹ä¸€å¼µ</button>
        <div style="font-size:11px; color:#888; text-align:center; margin-bottom: 10px;">
            åˆä½µå¾Œï¼Œçµæœå°‡è®Šæˆæ–°çš„åº•åœ–
        </div>

        <button onclick="saveResult()">ğŸ’¾ ä¸‹è¼‰ç›®å‰çµæœ</button>
    </div>

    <div id="main-area">
        <canvas id="stitchCanvas"></canvas>
    </div>

    <div id="right-panel">
        <div class="panel-header">
            <span>ğŸ“š å¾…è™•ç†åœ–ç‰‡</span>
            <div class="header-actions">
                <button class="btn-sm btn-danger-sm" onclick="clearQueue()" title="æ¸…ç©ºåˆ—è¡¨">ğŸ—‘ï¸</button>
                <button class="btn-sm" onclick="document.getElementById('multi-file-input').click()">â• åŠ å…¥</button>
            </div>
        </div>
        
        <input type="file" id="multi-file-input" multiple accept="image/*" onchange="handleFiles(this.files)">
        
        <div id="image-list">
            <div style="text-align:center; color:#666; margin-top:50px; font-size:14px;">
                ğŸ‘† é»æ“Šå³ä¸Šè§’åŠ å…¥åœ–ç‰‡<br>æˆ–æ˜¯å°‡åœ–ç‰‡æ‹–æ›³é€²ä¾†<br><br>å¯æ‹–æ›³å¡ç‰‡èª¿æ•´é †åº
            </div>
        </div>
    </div>

    <script>
        let queue = [];
        let cvReady = false;
        
        const canvas = document.getElementById('stitchCanvas');
        const ctx = canvas.getContext('2d');
        
        let baseImg = null;
        let activeImg = null;
        let baseImgObj = new Image();
        let activeImgObj = new Image();
        let isBaseLoaded = false;
        let isActiveLoaded = false;

        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastMouseX, lastMouseY;

        canvas.width = 800;
        canvas.height = 600;
        drawEmptyState();

        function onOpenCvReady() {
            cvReady = true;
            document.getElementById('cv-status').innerText = "å·²å°±ç·’";
            document.getElementById('cv-status').style.color = "#4CAF50";
            checkAutoButton();
        }

        function handleFiles(files) {
            if (!files.length) return;
            if (queue.length === 0) document.getElementById('image-list').innerHTML = '';

            Array.from(files).forEach(file => {
                const item = {
                    id: Date.now() + Math.random(),
                    file: file,
                    url: URL.createObjectURL(file),
                    name: file.name
                };
                queue.push(item);
            });
            
            renderList();
            loadCurrentPair();
        }

        // --- æ–°å¢ï¼šæ¸…ç©ºåˆ—è¡¨åŠŸèƒ½ ---
        function clearQueue() {
            if(queue.length > 0 && !confirm("ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰åœ–ç‰‡å—ï¼Ÿ")) return;
            
            // é‡‹æ”¾è¨˜æ†¶é«”
            queue.forEach(item => URL.revokeObjectURL(item.url));
            queue = [];
            
            renderList();
            loadCurrentPair();
        }
        // -----------------------

        function renderList() {
            const listEl = document.getElementById('image-list');
            listEl.innerHTML = '';

            if (queue.length === 0) {
                listEl.innerHTML = '<div style="text-align:center; color:#666; margin-top:50px; font-size:14px;">ğŸ‘† é»æ“Šå³ä¸Šè§’åŠ å…¥åœ–ç‰‡<br>æˆ–æ˜¯å°‡åœ–ç‰‡æ‹–æ›³é€²ä¾†</div>';
                return;
            }

            queue.forEach((item, index) => {
                const div = document.createElement("div");
                div.className = 'img-card';
                div.draggable = true;
                
                if (index === 0) div.classList.add('is-base');
                if (index === 1) div.classList.add('is-active');

                div.innerHTML = `
                    <div style="font-size:14px; color:#aaa; font-weight:bold;">${index + 1}</div>
                    <img src="${item.url}" class="thumb">
                    <div class="card-info">
                        <div class="filename" title="${item.name}">${item.name}</div>
                        ${index === 0 ? '<span class="role-tag" style="background:#2196F3; color:white;">åº•åœ– (Base)</span>' : ''}
                        ${index === 1 ? '<span class="role-tag" style="background:#FFC107; color:black;">ç§»å‹•ä¸­ (Top)</span>' : ''}
                    </div>
                    <div class="btn-del" onclick="removeFromQueue(${index})">Ã—</div>
                `;

                div.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', index);
                    div.classList.add('dragging');
                });
                div.addEventListener('dragend', () => div.classList.remove('dragging'));
                div.addEventListener('dragover', e => { e.preventDefault(); });
                div.addEventListener('drop', e => {
                    e.preventDefault();
                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIndex = index;
                    if (fromIndex !== toIndex) {
                        const movedItem = queue.splice(fromIndex, 1)[0];
                        queue.splice(toIndex, 0, movedItem);
                        renderList();
                        loadCurrentPair();
                    }
                });

                listEl.appendChild(div);
            });
        }

        function removeFromQueue(index) {
            URL.revokeObjectURL(queue[index].url); // é‡‹æ”¾è¨˜æ†¶é«”
            queue.splice(index, 1);
            renderList();
            loadCurrentPair();
        }

        function loadCurrentPair() {
            isBaseLoaded = false;
            isActiveLoaded = false;
            checkAutoButton();

            if (queue.length === 0) {
                drawEmptyState();
                return;
            }

            baseImg = queue[0];
            baseImgObj.onload = () => {
                isBaseLoaded = true;
                if (queue.length === 1) {
                    resetCanvasSize();
                    draw();
                } else {
                    checkAllLoaded();
                }
            };
            baseImgObj.src = baseImg.url;

            if (queue.length > 1) {
                activeImg = queue[1];
                activeImgObj.onload = () => {
                    isActiveLoaded = true;
                    offsetX = 0; 
                    offsetY = 0;
                    checkAllLoaded();
                };
                activeImgObj.src = activeImg.url;
            }
        }

        function checkAllLoaded() {
            if (isBaseLoaded && isActiveLoaded) {
                resetCanvasSize();
                draw();
                checkAutoButton();
            }
        }

        function resetCanvasSize() {
            canvas.width = baseImgObj.width + 400;
            canvas.height = baseImgObj.height + 400;
        }

        function drawEmptyState() {
            ctx.clearRect(0,0, canvas.width, canvas.height);
            ctx.fillStyle = "#666";
            ctx.font = "20px Microsoft JhengHei";
            ctx.textAlign = "center";
            ctx.fillText("è«‹å¾å³å´åŠ å…¥åœ–ç‰‡", canvas.width/2, canvas.height/2);
        }

        function checkAutoButton() {
            const btn = document.getElementById('btnAuto');
            btn.disabled = !(cvReady && isBaseLoaded && isActiveLoaded);
        }

        function draw(forSave = false) {
            if (!isBaseLoaded) return;

            let w = baseImgObj.width;
            let h = baseImgObj.height;
            if (isActiveLoaded) {
                const minX = Math.min(0, offsetX);
                const minY = Math.min(0, offsetY);
                const maxX = Math.max(w, offsetX + activeImgObj.width);
                const maxY = Math.max(h, offsetY + activeImgObj.height);
                
                canvas.width = maxX - minX;
                canvas.height = maxY - minY;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(-minX, -minY);
            } else {
                canvas.width = w;
                canvas.height = h;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
            }

            ctx.globalAlpha = 1.0;
            ctx.drawImage(baseImgObj, 0, 0);

            if (isActiveLoaded) {
                ctx.globalAlpha = forSave ? 1.0 : parseFloat(document.getElementById('alphaSlider').value);
                ctx.drawImage(activeImgObj, offsetX, offsetY);
            }

            ctx.restore();
            
            document.getElementById('valX').innerText = Math.round(offsetX);
            document.getElementById('valY').innerText = Math.round(offsetY);
        }

        canvas.addEventListener('mousedown', e => {
            if (!isActiveLoaded) return;
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        window.addEventListener('mousemove', e => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                offsetX += dx;
                offsetY += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                draw();
            }
        });
        window.addEventListener('mouseup', () => isDragging = false);

        function mergeAndNext() {
            if (!isBaseLoaded) return;
            if (queue.length < 2) {
                alert("æ²’æœ‰ä¸‹ä¸€å¼µåœ–ç‰‡å¯ä»¥åˆä½µå›‰ï¼");
                return;
            }

            draw(true);
            const mergedUrl = canvas.toDataURL('image/png');

            const newItem = {
                id: Date.now(),
                file: null,
                url: mergedUrl,
                name: `åˆä½µçµæœ_${queue.length - 1}`
            };

            // é‡‹æ”¾èˆŠåœ–è¨˜æ†¶é«”
            URL.revokeObjectURL(queue[0].url);
            URL.revokeObjectURL(queue[1].url);

            queue.splice(0, 2, newItem);
            renderList();
            loadCurrentPair();
        }

        function runAutoStitch() {
            if (!cvReady || !isBaseLoaded || !isActiveLoaded) return;
            
            const report = document.getElementById('analysis-report');
            report.style.display = 'block';
            report.innerHTML = "â³ è¨ˆç®—ä¸­...";

            setTimeout(() => {
                try {
                    let mat1 = cv.imread(baseImgObj);
                    let mat2 = cv.imread(activeImgObj);
                    
                    let gray1 = new cv.Mat();
                    let gray2 = new cv.Mat();
                    cv.cvtColor(mat1, gray1, cv.COLOR_RGBA2GRAY);
                    cv.cvtColor(mat2, gray2, cv.COLOR_RGBA2GRAY);

                    let orb = new cv.ORB(1000);
                    let kp1 = new cv.KeyPointVector();
                    let kp2 = new cv.KeyPointVector();
                    let des1 = new cv.Mat();
                    let des2 = new cv.Mat();

                    orb.detectAndCompute(gray1, new cv.Mat(), kp1, des1);
                    orb.detectAndCompute(gray2, new cv.Mat(), kp2, des2);

                    let bf = new cv.BFMatcher(cv.NORM_HAMMING, true);
                    let matches = new cv.DMatchVector();
                    bf.match(des1, des2, matches);

                    let goodMatches = [];
                    let sumX = 0, sumY = 0;
                    const searchRadius = 200;

                    for (let i = 0; i < matches.size(); i++) {
                        let m = matches.get(i);
                        let pt1 = kp1.get(m.queryIdx).pt;
                        let pt2 = kp2.get(m.trainIdx).pt;
                        let pdx = pt1.x - pt2.x;
                        let pdy = pt1.y - pt2.y;
                        
                        let dist = Math.sqrt(Math.pow(pdx - offsetX, 2) + Math.pow(pdy - offsetY, 2));
                        if (dist < searchRadius) {
                            goodMatches.push(m);
                            sumX += pdx;
                            sumY += pdy;
                        }
                    }

                    if (goodMatches.length < 3) {
                        report.innerHTML = `<span style="color:salmon">âŒ å¤±æ•—</span>: é™„è¿‘ç‰¹å¾µé»ä¸è¶³`;
                    } else {
                        offsetX = Math.round(sumX / goodMatches.length);
                        offsetY = Math.round(sumY / goodMatches.length);
                        draw();
                        report.innerHTML = `<span style="color:#4CAF50">âœ… æˆåŠŸ</span>: ä¾æ“š ${goodMatches.length} å€‹ç‰¹å¾µé»å¸é™„`;
                    }
                    
                    mat1.delete(); mat2.delete(); gray1.delete(); gray2.delete();
                    kp1.delete(); kp2.delete(); des1.delete(); des2.delete();
                    bf.delete(); matches.delete(); orb.delete();
                } catch(e) {
                    console.error(e);
                    report.innerHTML = "âŒ ç™¼ç”ŸéŒ¯èª¤";
                }
            }, 50);
        }

        function nudge(dx, dy) {
            offsetX += dx;
            offsetY += dy;
            draw();
        }

        function saveResult() {
            if (!isBaseLoaded) return;
            draw(true);
            const link = document.createElement('a');
            link.download = 'merge_result.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            draw();
        }
    </script>
</body>
</html>
