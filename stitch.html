<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šåœ–é€£çºŒæ‹¼æ¥å·¥ä½œç«™</title>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        /* --- åŸºç¤ä½ˆå±€ --- */
        body {
            font-family: "Microsoft JhengHei", Arial, sans-serif;
            background-color: #121212;
            color: #ddd;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* å·¦å´ï¼šæ§åˆ¶é¢æ¿ */
        #left-panel {
            width: 280px;
            min-width: 200px;
            background-color: #1e1e1e;
            padding: 15px;
            padding-top: 60px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.3);
            z-index: 10;
        }

        /* ä¸­é–“ï¼šç•«å¸ƒå€ */
        #main-area {
            flex-grow: 1;
            background-color: #222;
            background-image: linear-gradient(#333 1px, transparent 1px), linear-gradient(90deg, #333 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden; /* æ”¹ç‚º hiddenï¼Œç”¨ transform ç¸®æ”¾ */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* å³å´ï¼šåœ–ç‰‡ä½‡åˆ— (ä½ è¦æ±‚çš„å¤§å€å¡Š) */
        #right-panel {
            width: 300px;
            min-width: 200px;
            background-color: #1a1a1a;
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        /* å³å´æ¨™é¡Œå€ */
        .panel-header {
            padding: 15px;
            background: #252525;
            border-bottom: 1px solid #333;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* åœ–ç‰‡åˆ—è¡¨å®¹å™¨ */
        #image-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* åœ–ç‰‡å¡ç‰‡æ¨£å¼ */
        .img-card {
            background: #333;
            border-radius: 6px;
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: grab;
            border: 2px solid transparent;
            transition: 0.2s;
        }
        .img-card:hover { background: #444; }
        .img-card.dragging { opacity: 0.5; border: 2px dashed #888; }
        
        /* æ¨™ç¤ºç›®å‰æ­£åœ¨ä½¿ç”¨çš„åœ–ç‰‡ */
        .img-card.is-base { border-color: #2196F3; background: #192c3d; } /* è—è‰²ï¼šåº•åœ– */
        .img-card.is-active { border-color: #FFC107; background: #3d3419; } /* é»ƒè‰²ï¼šä¸Šå±¤åœ– */

        .thumb {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 4px;
            background: #000;
        }

        .card-info {
            flex-grow: 1;
            overflow: hidden;
        }
        .filename {
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #fff;
        }
        .role-tag {
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 3px;
            margin-top: 4px;
            display: inline-block;
        }

        /* åˆªé™¤æŒ‰éˆ• */
        .btn-del {
            color: #666;
            cursor: pointer;
            padding: 4px;
            font-size: 16px;
        }
        .btn-del:hover { color: #ff5252; }

        /* --- ä¸€èˆ¬ UI å…ƒä»¶ --- */
        h2 { margin: 0 0 5px 0; color: #FFB74D; font-size: 18px; }
        button {
            padding: 10px;
            font-size: 14px;
            cursor: pointer;
            background-color: #444;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            width: 100%;
            transition: 0.2s;
            margin-bottom: 5px;
        }
        button:hover { background-color: #666; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-primary { background-color: #1976D2; border-color: #1565C0; font-weight: bold; }
        .btn-success { background-color: #43A047; border-color: #2E7D32; font-weight: bold; }
        .btn-auto { background-color: #7B1FA2; border-color: #4A148C; color: white; }
        
        /* æª”æ¡ˆä¸Šå‚³éš±è— */
        #multi-file-input { display: none; }

        /* å›é¦–é æŒ‰éˆ• */
        .home-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            text-decoration: none;
            background: #444;
            padding: 6px 12px;
            border-radius: 20px;
            color: #fff;
            font-size: 12px;
            border: 1px solid #666;
            z-index: 100;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }

        #analysis-report {
            font-size: 12px; color: #81D4FA; background: #263238;
            padding: 10px; border-radius: 4px; border-left: 3px solid #0288D1;
            display: none; margin-top: 10px; line-height: 1.5;
        }
    </style>
</head>
<body>

    <a href="index.html" class="home-btn">ğŸ  å›é¦–é </a>

    <div id="left-panel">
        <h2>ğŸ§© æ§åˆ¶å°</h2>
        
        <div style="font-size:12px; color:#aaa; margin-bottom:10px;">
            OpenCV: <span id="cv-status" style="color:yellow">è¼‰å…¥ä¸­...</span>
        </div>

        <label>é€æ˜åº¦ (æª¢æŸ¥å°é½Š)</label>
        <input type="range" id="alphaSlider" min="0" max="1" step="0.05" value="0.6" oninput="draw()">

        <div style="height: 10px;"></div> <button id="btnAuto" class="btn-auto" onclick="runAutoStitch()" disabled>ğŸª„ AI è‡ªå‹•å¸é™„ (ç›®å‰ä½ç½®)</button>
        <div id="analysis-report"></div>

        <div style="height: 10px;"></div>

        <label>éµç›¤å¾®èª¿</label>
        <div style="display: flex; gap: 5px;">
            <button onclick="nudge(-1, 0)">â¬…ï¸</button>
            <button onclick="nudge(0, -1)">â¬†ï¸</button>
            <button onclick="nudge(0, 1)">â¬‡ï¸</button>
            <button onclick="nudge(1, 0)">â¡ï¸</button>
        </div>
        <div style="text-align: center; font-size: 12px; color: #888;">
            X: <span id="valX">0</span>, Y: <span id="valY">0</span>
        </div>

        <div style="margin-top: auto;"></div> <button class="btn-success" onclick="mergeAndNext()">âœ… åˆä½µä¸¦æ›ä¸‹ä¸€å¼µ</button>
        <div style="font-size:11px; color:#888; text-align:center; margin-bottom: 10px;">
            åˆä½µå¾Œï¼Œçµæœå°‡è®Šæˆæ–°çš„åº•åœ–
        </div>

        <button onclick="saveResult()">ğŸ’¾ ä¸‹è¼‰ç›®å‰çµæœ</button>
    </div>

    <div id="main-area">
        <canvas id="stitchCanvas"></canvas>
    </div>

    <div id="right-panel">
        <div class="panel-header">
            <span>ğŸ“š å¾…è™•ç†åœ–ç‰‡</span>
            <button style="width: auto; padding: 5px 10px; margin:0;" onclick="document.getElementById('multi-file-input').click()">
                â• åŠ å…¥åœ–ç‰‡
            </button>
        </div>
        
        <input type="file" id="multi-file-input" multiple accept="image/*" onchange="handleFiles(this.files)">
        
        <div id="image-list">
            <div style="text-align:center; color:#666; margin-top:50px; font-size:14px;">
                ğŸ‘† é»æ“Šå³ä¸Šè§’åŠ å…¥åœ–ç‰‡<br>æˆ–æ˜¯å°‡åœ–ç‰‡æ‹–æ›³é€²ä¾†<br><br>å¯æ‹–æ›³å¡ç‰‡èª¿æ•´é †åº
            </div>
        </div>
    </div>

    <script>
        // --- è®Šæ•¸èˆ‡ç‹€æ…‹ ---
        let queue = []; // å­˜æ”¾æ‰€æœ‰åœ–ç‰‡ç‰©ä»¶ {id, file, url, name}
        let cvReady = false;
        
        // ç•«å¸ƒèˆ‡ Context
        const canvas = document.getElementById('stitchCanvas');
        const ctx = canvas.getContext('2d');
        
        // ç›®å‰æ­£åœ¨æ‹¼æ¥çš„å…©å¼µåœ–
        let baseImg = null;  // åº•åœ– (é€šå¸¸æ˜¯ Index 0)
        let activeImg = null; // ä¸Šå±¤åœ– (é€šå¸¸æ˜¯ Index 1)
        let baseImgObj = new Image();
        let activeImgObj = new Image();
        let isBaseLoaded = false;
        let isActiveLoaded = false;

        // ä½ç§»ç‹€æ…‹
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastMouseX, lastMouseY;

        // åˆå§‹åŒ–
        canvas.width = 800;
        canvas.height = 600;
        drawEmptyState();

        // --- OpenCV ---
        function onOpenCvReady() {
            cvReady = true;
            document.getElementById('cv-status').innerText = "å·²å°±ç·’";
            document.getElementById('cv-status').style.color = "#4CAF50";
            checkAutoButton();
        }

        // --- æª”æ¡ˆè™•ç† (ä½‡åˆ—é‚è¼¯) ---
        function handleFiles(files) {
            if (!files.length) return;
            
            // æ¸…é™¤é è¨­æç¤º
            if (queue.length === 0) document.getElementById('image-list').innerHTML = '';

            Array.from(files).forEach(file => {
                const item = {
                    id: Date.now() + Math.random(),
                    file: file,
                    url: URL.createObjectURL(file),
                    name: file.name
                };
                queue.push(item);
            });
            
            renderList();
            loadCurrentPair(); // å˜—è©¦è¼‰å…¥å‰å…©å¼µ
        }

        // --- æ¸²æŸ“å³å´åˆ—è¡¨ ---
        function renderList() {
            const listEl = document.getElementById('image-list');
            listEl.innerHTML = '';

            queue.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'img-card';
                div.draggable = true;
                
                // æ¨™è¨˜ç‹€æ…‹
                if (index === 0) div.classList.add('is-base');
                if (index === 1) div.classList.add('is-active');

                // å¡ç‰‡å…§å®¹
                div.innerHTML = `
                    <div style="font-size:14px; color:#aaa; font-weight:bold;">${index + 1}</div>
                    <img src="${item.url}" class="thumb">
                    <div class="card-info">
                        <div class="filename" title="${item.name}">${item.name}</div>
                        ${index === 0 ? '<span class="role-tag" style="background:#2196F3; color:white;">åº•åœ– (Base)</span>' : ''}
                        ${index === 1 ? '<span class="role-tag" style="background:#FFC107; color:black;">ç§»å‹•ä¸­ (Top)</span>' : ''}
                    </div>
                    <div class="btn-del" onclick="removeFromQueue(${index})">Ã—</div>
                `;

                // --- æ‹–æ›³æ’åºäº‹ä»¶ ---
                div.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', index);
                    div.classList.add('dragging');
                });
                div.addEventListener('dragend', () => div.classList.remove('dragging'));
                
                // å…è¨±æ”¾ç½®
                div.addEventListener('dragover', e => { e.preventDefault(); });
                div.addEventListener('drop', e => {
                    e.preventDefault();
                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIndex = index;
                    if (fromIndex !== toIndex) {
                        // äº¤æ›é™£åˆ—å…ƒç´ 
                        const movedItem = queue.splice(fromIndex, 1)[0];
                        queue.splice(toIndex, 0, movedItem);
                        renderList();
                        loadCurrentPair(); // é †åºæ”¹è®Šï¼Œé‡æ–°è¼‰å…¥
                    }
                });

                listEl.appendChild(div);
            });
        }

        function removeFromQueue(index) {
            queue.splice(index, 1);
            renderList();
            loadCurrentPair();
        }

        // --- è¼‰å…¥ç›®å‰è¦æ‹¼æ¥çš„ä¸€å° (Index 0 å’Œ Index 1) ---
        function loadCurrentPair() {
            // é‡ç½®ç‹€æ…‹
            isBaseLoaded = false;
            isActiveLoaded = false;
            checkAutoButton();

            if (queue.length === 0) {
                drawEmptyState();
                return;
            }

            // è¼‰å…¥åº•åœ– (Index 0)
            baseImg = queue[0];
            baseImgObj.onload = () => {
                isBaseLoaded = true;
                // å¦‚æœæ²’æœ‰ç¬¬äºŒå¼µåœ–ï¼Œå°±åªç•«ç¬¬ä¸€å¼µä¸¦èª¿æ•´ç•«å¸ƒ
                if (queue.length === 1) {
                    resetCanvasSize();
                    draw();
                } else {
                    checkAllLoaded();
                }
            };
            baseImgObj.src = baseImg.url;

            // è¼‰å…¥ä¸Šå±¤åœ– (Index 1)
            if (queue.length > 1) {
                activeImg = queue[1];
                activeImgObj.onload = () => {
                    isActiveLoaded = true;
                    // é è¨­ä½ç½®æ­¸é›¶ (æˆ–æ˜¯å¯ä»¥ä¿ç•™ä¸Šæ¬¡çš„ä½ç½®ç­–ç•¥ï¼Œé€™è£¡å…ˆæ­¸é›¶)
                    offsetX = 0; 
                    offsetY = 0;
                    checkAllLoaded();
                };
                activeImgObj.src = activeImg.url;
            }
        }

        function checkAllLoaded() {
            if (isBaseLoaded && isActiveLoaded) {
                // åˆå§‹åŒ–ç•«å¸ƒå¤§å°
                resetCanvasSize();
                draw();
                checkAutoButton();
            }
        }

        function resetCanvasSize() {
            // é è¨­ç•«å¸ƒå¤§å°ç‚ºåº•åœ–å¤§å° + é‚Šè·
            canvas.width = baseImgObj.width + 400;
            canvas.height = baseImgObj.height + 400;
        }

        function drawEmptyState() {
            ctx.clearRect(0,0, canvas.width, canvas.height);
            ctx.fillStyle = "#666";
            ctx.font = "20px Microsoft JhengHei";
            ctx.textAlign = "center";
            ctx.fillText("è«‹å¾å³å´åŠ å…¥åœ–ç‰‡", canvas.width/2, canvas.height/2);
        }

        function checkAutoButton() {
            const btn = document.getElementById('btnAuto');
            btn.disabled = !(cvReady && isBaseLoaded && isActiveLoaded);
        }

        // --- ç¹ªåœ–æ ¸å¿ƒ ---
        function draw(forSave = false) {
            if (!isBaseLoaded) return;

            // å‹•æ…‹èª¿æ•´ç•«å¸ƒå¤§å° (åŒ…åœç›’)
            let w = baseImgObj.width;
            let h = baseImgObj.height;
            if (isActiveLoaded) {
                // è¨ˆç®—å…©å¼µåœ–çš„æœ€å¤§ç¯„åœ
                const minX = Math.min(0, offsetX);
                const minY = Math.min(0, offsetY);
                const maxX = Math.max(w, offsetX + activeImgObj.width);
                const maxY = Math.max(h, offsetY + activeImgObj.height);
                
                canvas.width = maxX - minX;
                canvas.height = maxY - minY;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(-minX, -minY);
            } else {
                canvas.width = w;
                canvas.height = h;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
            }

            // ç•«åº•åœ–
            ctx.globalAlpha = 1.0;
            ctx.drawImage(baseImgObj, 0, 0);

            // ç•«ä¸Šå±¤åœ–
            if (isActiveLoaded) {
                ctx.globalAlpha = forSave ? 1.0 : parseFloat(document.getElementById('alphaSlider').value);
                ctx.drawImage(activeImgObj, offsetX, offsetY);
            }

            ctx.restore();
            
            // æ›´æ–° UI
            document.getElementById('valX').innerText = Math.round(offsetX);
            document.getElementById('valY').innerText = Math.round(offsetY);
        }

        // --- æ»‘é¼ æ‹–æ›³ ---
        canvas.addEventListener('mousedown', e => {
            if (!isActiveLoaded) return;
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        window.addEventListener('mousemove', e => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                offsetX += dx;
                offsetY += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                draw();
            }
        });
        window.addEventListener('mouseup', () => isDragging = false);

        // --- åŠŸèƒ½ï¼šåˆä½µä¸¦æ›ä¸‹ä¸€å¼µ (é—œéµåŠŸèƒ½) ---
        function mergeAndNext() {
            if (!isBaseLoaded) return;
            if (queue.length < 2) {
                alert("æ²’æœ‰ä¸‹ä¸€å¼µåœ–ç‰‡å¯ä»¥åˆä½µå›‰ï¼");
                return;
            }

            // 1. ç”¢ç”Ÿåˆä½µå¾Œçš„åœ–ç‰‡ DataURL
            draw(true); // å¼·åˆ¶ä¸é€æ˜ç¹ªè£½
            const mergedUrl = canvas.toDataURL('image/png');

            // 2. æ›´æ–°ä½‡åˆ—
            // æŠŠ Index 0 å’Œ Index 1 ç§»é™¤ï¼Œå°‡åˆä½µçµæœæ’å…¥è®Šæˆæ–°çš„ Index 0
            const newItem = {
                id: Date.now(),
                file: null, // é€™æ˜¯ç”Ÿæˆçš„ï¼Œæ²’æœ‰åŸå§‹ File ç‰©ä»¶
                url: mergedUrl,
                name: `åˆä½µçµæœ_${queue.length}`
            };

            // ç§»é™¤å‰å…©å€‹ï¼Œæ’å…¥æ–°çš„
            queue.splice(0, 2, newItem);

            // 3. æ›´æ–°ä»‹é¢
            renderList();
            loadCurrentPair(); // é€™æœƒè‡ªå‹•è¼‰å…¥æ–°çš„ Index 0 (å‰›åˆä½µçš„) å’ŒåŸæœ¬çš„ Index 2 (ç¾åœ¨è®Šæˆ Index 1)
        }

        // --- åŠŸèƒ½ï¼šAI è‡ªå‹•å°é½Š (ä¿ç•™åŸæœ¬é‚è¼¯) ---
        function runAutoStitch() {
            if (!cvReady || !isBaseLoaded || !isActiveLoaded) return;
            
            const report = document.getElementById('analysis-report');
            report.style.display = 'block';
            report.innerHTML = "â³ è¨ˆç®—ä¸­...";

            setTimeout(() => {
                try {
                    let mat1 = cv.imread(baseImgObj);
                    let mat2 = cv.imread(activeImgObj);
                    
                    let gray1 = new cv.Mat();
                    let gray2 = new cv.Mat();
                    cv.cvtColor(mat1, gray1, cv.COLOR_RGBA2GRAY);
                    cv.cvtColor(mat2, gray2, cv.COLOR_RGBA2GRAY);

                    let orb = new cv.ORB(1000);
                    let kp1 = new cv.KeyPointVector();
                    let kp2 = new cv.KeyPointVector();
                    let des1 = new cv.Mat();
                    let des2 = new cv.Mat();

                    orb.detectAndCompute(gray1, new cv.Mat(), kp1, des1);
                    orb.detectAndCompute(gray2, new cv.Mat(), kp2, des2);

                    let bf = new cv.BFMatcher(cv.NORM_HAMMING, true);
                    let matches = new cv.DMatchVector();
                    bf.match(des1, des2, matches);

                    let goodMatches = [];
                    let sumX = 0, sumY = 0;
                    const searchRadius = 200;

                    for (let i = 0; i < matches.size(); i++) {
                        let m = matches.get(i);
                        let pt1 = kp1.get(m.queryIdx).pt;
                        let pt2 = kp2.get(m.trainIdx).pt;
                        let pdx = pt1.x - pt2.x;
                        let pdy = pt1.y - pt2.y;
                        
                        let dist = Math.sqrt(Math.pow(pdx - offsetX, 2) + Math.pow(pdy - offsetY, 2));
                        if (dist < searchRadius) {
                            goodMatches.push(m);
                            sumX += pdx;
                            sumY += pdy;
                        }
                    }

                    if (goodMatches.length < 3) {
                        report.innerHTML = `<span style="color:salmon">âŒ å¤±æ•—</span>: é™„è¿‘ç‰¹å¾µé»ä¸è¶³`;
                    } else {
                        offsetX = Math.round(sumX / goodMatches.length);
                        offsetY = Math.round(sumY / goodMatches.length);
                        draw();
                        report.innerHTML = `<span style="color:#4CAF50">âœ… æˆåŠŸ</span>: ä¾æ“š ${goodMatches.length} å€‹ç‰¹å¾µé»å¸é™„`;
                    }
                    
                    // æ¸…ç†
                    mat1.delete(); mat2.delete(); gray1.delete(); gray2.delete();
                    kp1.delete(); kp2.delete(); des1.delete(); des2.delete();
                    bf.delete(); matches.delete(); orb.delete();
                } catch(e) {
                    console.error(e);
                    report.innerHTML = "âŒ ç™¼ç”ŸéŒ¯èª¤";
                }
            }, 50);
        }

        function nudge(dx, dy) {
            offsetX += dx;
            offsetY += dy;
            draw();
        }

        function saveResult() {
            if (!isBaseLoaded) return;
            draw(true);
            const link = document.createElement('a');
            link.download = 'merge_result.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            draw();
        }
    </script>
</body>
</html>
