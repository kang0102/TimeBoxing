<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºæ…§åœ–ç‰‡æ‹¼æ¥å·¥å…·</title>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        body {
            font-family: "Microsoft JhengHei", Arial, sans-serif;
            background-color: #1e1e1e;
            color: #ddd;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #sidebar {
            width: 300px;
            background-color: #2b2b2b;
            padding: 15px;
            padding-top: 60px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.5);
            z-index: 10;
            overflow-y: auto;
        }

        #main-area {
            flex-grow: 1;
            background-color: #333;
            background-image: linear-gradient(#444 1px, transparent 1px), linear-gradient(90deg, #444 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        h2 { margin: 0 0 5px 0; color: #FFB74D; font-size: 18px; }

        .control-group {
            background: #222;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #444;
        }

        label { display: block; margin-bottom: 5px; font-size: 13px; color: #bbb; }
        
        button {
            padding: 10px;
            font-size: 14px;
            cursor: pointer;
            background-color: #444;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            width: 100%;
            transition: 0.2s;
            margin-bottom: 5px;
        }
        button:hover { background-color: #666; }
        button:disabled { background-color: #333; color: #666; cursor: not-allowed; }

        .btn-auto { background-color: #7B1FA2; border-color: #4A148C; color: white; font-weight: bold;}
        .btn-auto:hover { background-color: #9C27B0; }

        .btn-save { background-color: #43A047; border-color: #2E7D32; font-weight: bold; margin-top: 10px;}

        input[type="range"] { width: 100%; margin: 5px 0; }

        .home-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            text-decoration: none;
            background: #444;
            padding: 8px 15px;
            border-radius: 20px;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
            border: 1px solid #666;
            z-index: 100;
        }

        /* åˆ†æå ±å‘Šå€å¡Š */
        #analysis-report {
            font-size: 12px;
            color: #81D4FA;
            background: #1a1a1a;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #0288D1;
            display: none; /* é è¨­éš±è— */
            line-height: 1.5;
        }

        canvas {
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }
        
        /* è¼‰å…¥é®ç½© */
        #loading-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            flex-direction: column;
        }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <div style="font-size: 24px;">ğŸ”§ æ­£åœ¨åˆå§‹åŒ–å½±åƒå¼•æ“ (OpenCV)...</div>
        <div style="font-size: 14px; color: #aaa; margin-top: 10px;">é¦–æ¬¡è¼‰å…¥å¯èƒ½éœ€è¦å¹¾ç§’é˜</div>
    </div>

    <a href="index.html" class="home-btn">ğŸ  å›é¦–é </a>

    <div id="sidebar">
        <h2>ğŸ§© æ™ºæ…§åœ–ç‰‡æ‹¼æ¥</h2>
        <div id="cv-status" style="font-size:10px; color:#666; margin-bottom:10px;">OpenCV ç‹€æ…‹: è¼‰å…¥ä¸­...</div>

        <div class="control-group">
            <label>1. åœ–ç‰‡ä¾†æº</label>
            <button onclick="document.getElementById('file1').click()">ğŸ“‚ è¼‰å…¥åº•åœ– (Image 1)</button>
            <input type="file" id="file1" accept="image/*" style="display:none" onchange="loadImg(1, this)">
            
            <button onclick="document.getElementById('file2').click()">ğŸ“‚ è¼‰å…¥ä¸Šå±¤åœ– (Image 2)</button>
            <input type="file" id="file2" accept="image/*" style="display:none" onchange="loadImg(2, this)">
        </div>

        <div class="control-group" style="border-color: #7B1FA2;">
            <label style="color: #E1BEE7;">ğŸ¤– è‡ªå‹•åŒ–æ“ä½œ</label>
            <button id="btnAuto" class="btn-auto" onclick="runAutoStitch()" disabled>ğŸª„ åŸ·è¡Œè‡ªå‹•å°é½Š</button>
            
            <div id="analysis-report">
                å°šæœªåŸ·è¡Œåˆ†æ...
            </div>
        </div>

        <div class="control-group">
            <label>ğŸ› ï¸ æ‰‹å‹•å¾®èª¿ (X / Y)</label>
            <input type="range" id="alphaSlider" min="0" max="1" step="0.05" value="0.6" oninput="draw()" title="é€æ˜åº¦">
            
            <div style="display: flex; gap: 5px; margin-top:5px;">
                <button onclick="nudge(-1, 0)">â¬…ï¸</button>
                <button onclick="nudge(0, -1)">â¬†ï¸</button>
                <button onclick="nudge(0, 1)">â¬‡ï¸</button>
                <button onclick="nudge(1, 0)">â¡ï¸</button>
            </div>
            <div style="font-size: 12px; margin-top: 5px; color: #888;">
                ä½ç½®: <span id="valX">0</span>, <span id="valY">0</span>
            </div>
        </div>

        <button class="btn-save" onclick="saveResult()">ğŸ’¾ ä¸‹è¼‰åˆæˆåœ–</button>
    </div>

    <div id="main-area">
        <canvas id="stitchCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('stitchCanvas');
        const ctx = canvas.getContext('2d');
        
        let img1 = new Image();
        let img2 = new Image();
        let loaded1 = false;
        let loaded2 = false;
        let cvReady = false;

        let offsetX = 0;
        let offsetY = 0;
        
        let isDragging = false;
        let lastMouseX, lastMouseY;

        // åˆå§‹åŒ–
        canvas.width = 800;
        canvas.height = 600;
        ctx.fillStyle = "#aaa";
        ctx.font = "20px Microsoft JhengHei";
        ctx.textAlign = "center";
        ctx.fillText("ç³»çµ±æº–å‚™ä¸­...", 400, 300);

        // --- OpenCV è¼‰å…¥ç›£è½ ---
        function onOpenCvReady() {
            cvReady = true;
            document.getElementById('loading-overlay').style.display = 'none';
            document.getElementById('cv-status').innerText = "OpenCV ç‹€æ…‹: âœ… å·²å°±ç·’ (v4.5.0)";
            document.getElementById('cv-status').style.color = "#4CAF50";
            checkButtons();
            ctx.clearRect(0,0,canvas.width, canvas.height);
            ctx.fillText("è«‹ä¾åºè¼‰å…¥å…©å¼µåœ–ç‰‡", 400, 300);
        }

        function loadImg(idx, input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        if (idx === 1) { 
                            img1 = tempImg; loaded1 = true; 
                        } else { 
                            img2 = tempImg; loaded2 = true; 
                        }
                        checkInit();
                    };
                    tempImg.src = e.target.result;
                }
                reader.readAsDataURL(input.files[0]);
            }
        }

        function checkInit() {
            if (loaded1) {
                if (!loaded2) {
                    canvas.width = img1.width + 400;
                    canvas.height = img1.height + 400;
                }
                draw();
            }
            checkButtons();
        }

        function checkButtons() {
            const btn = document.getElementById('btnAuto');
            if(cvReady && loaded1 && loaded2) {
                btn.disabled = false;
                btn.innerText = "ğŸª„ åŸ·è¡Œè‡ªå‹•å°é½Š";
            } else {
                btn.disabled = true;
                if(!cvReady) btn.innerText = "ç­‰å¾…å¼•æ“...";
                else btn.innerText = "éœ€è¼‰å…¥å…©å¼µåœ–";
            }
        }

        // --- æ ¸å¿ƒï¼šè‡ªå‹•åˆæˆé‚è¼¯ ---
        function runAutoStitch() {
            if (!cvReady || !loaded1 || !loaded2) return;
            
            const report = document.getElementById('analysis-report');
            report.style.display = 'block';
            report.innerHTML = "â³ è¨ˆç®—ä¸­ï¼Œè«‹ç¨å€™...";

            // ä½¿ç”¨ setTimeout è®“ UI æœ‰æ©Ÿæœƒæ¸²æŸ“ "è¨ˆç®—ä¸­" æ–‡å­—
            setTimeout(() => {
                try {
                    // 1. è®€å–åœ–ç‰‡åˆ° OpenCV æ ¼å¼
                    let mat1 = cv.imread(img1);
                    let mat2 = cv.imread(img2);
                    
                    // 2. è½‰ç°éš (ç‰¹å¾µåŒ¹é…ä¸éœ€è¦é¡è‰²)
                    let gray1 = new cv.Mat();
                    let gray2 = new cv.Mat();
                    cv.cvtColor(mat1, gray1, cv.COLOR_RGBA2GRAY);
                    cv.cvtColor(mat2, gray2, cv.COLOR_RGBA2GRAY);

                    // 3. å‰µå»º ORB ç‰¹å¾µåµæ¸¬å™¨
                    let orb = new cv.ORB(500); // å°‹æ‰¾æœ€å¤š 500 å€‹ç‰¹å¾µé»
                    let keypoints1 = new cv.KeyPointVector();
                    let keypoints2 = new cv.KeyPointVector();
                    let descriptors1 = new cv.Mat();
                    let descriptors2 = new cv.Mat();

                    // 4. åµæ¸¬èˆ‡è¨ˆç®—ç‰¹å¾µ
                    orb.detectAndCompute(gray1, new cv.Mat(), keypoints1, descriptors1);
                    orb.detectAndCompute(gray2, new cv.Mat(), keypoints2, descriptors2);

                    // 5. ç‰¹å¾µåŒ¹é… (ä½¿ç”¨ Hamming è·é›¢)
                    let bf = new cv.BFMatcher(cv.NORM_HAMMING, true);
                    let matches = new cv.DMatchVector();
                    bf.match(descriptors1, descriptors2, matches);

                    // 6. éæ¿¾è‰¯å¥½çš„åŒ¹é…é» (è¨ˆç®—ä½ç§»)
                    let goodMatches = [];
                    let sumDX = 0;
                    let sumDY = 0;
                    // åªå–è·é›¢å°æ–¼ç‰¹å®šé–¾å€¼çš„é»
                    let minDist = 1000;
                    for (let i = 0; i < matches.size(); i++) {
                        let dist = matches.get(i).distance;
                        if(dist < minDist) minDist = dist;
                    }
                    
                    // å¯¬é¬†é–¾å€¼ï¼šæœ€å°è·é›¢çš„ 3 å€ï¼Œä½†ä¸è¶…é 50
                    let threshold = Math.max(3 * minDist, 50);

                    for (let i = 0; i < matches.size(); i++) {
                        let m = matches.get(i);
                        if (m.distance <= threshold) {
                            goodMatches.push(m);
                            // å–å¾—é€™å…©å€‹é»çš„åº§æ¨™
                            let pt1 = keypoints1.get(m.queryIdx).pt; // åº•åœ–é»
                            let pt2 = keypoints2.get(m.trainIdx).pt; // ä¸Šå±¤åœ–é»
                            
                            // ç®—å‡ºä½ç§»: åº•åœ–åº§æ¨™ - ä¸Šå±¤åœ–åº§æ¨™ = ä¸Šå±¤åœ–æ‡‰è©²ç§»å‹•çš„è·é›¢
                            sumDX += (pt1.x - pt2.x);
                            sumDY += (pt1.y - pt2.y);
                        }
                    }

                    // 7. åˆ¤æ–·èˆ‡å›é¥‹
                    let count = goodMatches.length;
                    let totalFeatures = Math.min(keypoints1.size(), keypoints2.size());
                    // ç°¡å–®ä¿¡å¿ƒæŒ‡æ•¸ï¼š(åŒ¹é…é» / åµæ¸¬é») * åŠ æ¬Š
                    let confidence = totalFeatures > 0 ? (count / totalFeatures) * 100 : 0;
                    confidence = Math.min(confidence * 2, 100); // åŠ æ¬Šèª¿æ•´é¡¯ç¤º

                    if (count < 4) {
                        // å¤±æ•—ï¼šé»å¤ªå°‘
                        report.innerHTML = 
                            `<span style="color:#FF5252">âŒ è‡ªå‹•åˆæˆå¤±æ•—</span><br>` +
                            `ç‰¹å¾µé»ä¸è¶³ (åƒ… ${count} é»)<br>` +
                            `ç³»çµ±å·²åˆ‡æ›è‡³æ‰‹å‹•æ¨¡å¼ï¼Œè«‹è‡ªè¡Œæ‹–æ›³åœ–ç‰‡ã€‚`;
                        report.style.borderLeftColor = "#FF5252";
                    } else {
                        // æˆåŠŸï¼šè¨ˆç®—å¹³å‡ä½ç§»
                        let avgX = sumDX / count;
                        let avgY = sumDY / count;
                        
                        offsetX = Math.round(avgX);
                        offsetY = Math.round(avgY);
                        draw(); // æ›´æ–°ç•«é¢

                        let qualityText = "å°šå¯";
                        let qualityColor = "yellow";
                        if(confidence > 60) { qualityText = "å®Œç¾"; qualityColor = "#00E676"; }
                        else if(confidence < 20) { qualityText = "ä½ (å»ºè­°æª¢æŸ¥)"; qualityColor = "#FF5252"; }

                        report.innerHTML = 
                            `<span style="color:#00E676">âœ… è‡ªå‹•å°é½ŠæˆåŠŸ</span><br>` +
                            `åŒ¹é…é»æ•¸: <b>${count}</b> / ${matches.size()}<br>` +
                            `å»åˆä¿¡å¿ƒåº¦: <span style="color:${qualityColor}">${confidence.toFixed(1)}% (${qualityText})</span><br>` +
                            `åˆ¤æ–·ä¾æ“š: é€é ORB ç‰¹å¾µé»å¹¾ä½•è·é›¢è¨ˆç®—<br>` +
                            `ä½ç§»çµæœ: X=${offsetX}, Y=${offsetY}`;
                        report.style.borderLeftColor = "#00E676";
                    }

                    // é‡‹æ”¾è¨˜æ†¶é«”
                    mat1.delete(); mat2.delete(); gray1.delete(); gray2.delete();
                    keypoints1.delete(); keypoints2.delete();
                    descriptors1.delete(); descriptors2.delete();
                    bf.delete(); matches.delete(); orb.delete();

                } catch (err) {
                    console.error(err);
                    report.innerHTML = `<span style="color:red">âŒ ç™¼ç”ŸéŒ¯èª¤</span><br>OpenCV è™•ç†å¤±æ•—ï¼Œè«‹æ”¹ç”¨æ‰‹å‹•ã€‚`;
                }
            }, 100); // å»¶é²çµæŸ
        }

        // --- ç¹ªåœ–èˆ‡æ‰‹å‹•æ“ä½œ ---
        function draw(forSave = false) {
            if (!loaded1) return;

            let minX = Math.min(0, offsetX);
            let minY = Math.min(0, offsetY);
            let maxX = Math.max(img1.width, offsetX + (loaded2 ? img2.width : 0));
            let maxY = Math.max(img1.height, offsetY + (loaded2 ? img2.height : 0));

            canvas.width = maxX - minX;
            canvas.height = maxY - minY;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(-minX, -minY);

            ctx.globalAlpha = 1.0;
            ctx.drawImage(img1, 0, 0);

            if (loaded2) {
                ctx.globalAlpha = forSave ? 1.0 : parseFloat(document.getElementById('alphaSlider').value);
                ctx.drawImage(img2, offsetX, offsetY);
            }
            ctx.restore();

            document.getElementById('valX').innerText = parseInt(offsetX);
            document.getElementById('valY').innerText = parseInt(offsetY);
        }

        canvas.addEventListener('mousedown', e => {
            if (!loaded2) return;
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        window.addEventListener('mousemove', e => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                offsetX += dx;
                offsetY += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                draw();
            }
        });

        window.addEventListener('mouseup', () => isDragging = false);

        function nudge(dx, dy) {
            offsetX += dx;
            offsetY += dy;
            draw();
        }

        function saveResult() {
            if (!loaded1) return;
            draw(true);
            const link = document.createElement('a');
            link.download = 'stitched_auto_result.jpg';
            link.href = canvas.toDataURL('image/jpeg', 0.9);
            link.click();
            draw(false);
        }
    </script>
</body>
</html>
