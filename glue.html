<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è† é«”åˆ†æå·¥å…· v4.0 (è¨­å®šå­˜å–+é‚Šç·£è¦–è¦ºåŒ–)</title>
    <style>
        /* --- æ¨£å¼è¨­å®š --- */
        body { font-family: "Microsoft JhengHei", Arial, sans-serif; background-color: #1e1e1e; color: #ddd; margin: 0; display: flex; height: 100vh; overflow: hidden; user-select: none; }
        
        #sidebar { width: 340px; background-color: #2b2b2b; padding: 15px; padding-top: 20px; display: flex; flex-direction: column; gap: 8px; box-shadow: 2px 0 5px rgba(0,0,0,0.5); z-index: 10; overflow-y: auto; flex-shrink: 0; }
        #main-area { flex-grow: 1; position: relative; background-color: #333; overflow: hidden; cursor: crosshair; }
        
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }

        h2 { margin: 0 0 10px 0; color: #00E5FF; font-size: 18px; }
        h3 { margin: 15px 0 5px 0; color: #aaa; font-size: 13px; border-bottom: 1px solid #444; padding-bottom: 2px; text-transform: uppercase; letter-spacing: 1px;}
        
        button { padding: 8px; font-size: 13px; cursor: pointer; background-color: #444; color: white; border: 1px solid #555; border-radius: 4px; transition: 0.2s; width: 100%; text-align: center; margin-bottom: 2px;}
        button:hover { background-color: #666; }
        button.active { background-color: #00897B; border-color: #00695C; font-weight: bold; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
        button.action { background-color: #388E3C; border-color: #2E7D32; font-weight: bold; font-size: 14px; padding: 10px; margin-top: 10px;}
        button.db-btn { background-color: #d84315; border-color: #bf360c; font-weight: bold; margin-top: 5px; }
        button.db-btn:hover { background-color: #f4511e; }
        button.toggle-snap { border: 1px solid #E91E63; color: #F8BBD0; }
        button.toggle-snap.active { background-color: #C2185B; color: white; }
        
        .btn-row { display: flex; gap: 5px; }
        .control-row { display: flex; gap: 5px; align-items: center; margin-bottom: 5px; }
        .control-row label { flex: 1; font-size: 12px; color: #ccc; }
        
        select, input[type="number"], input[type="text"] { background: #333; color: white; border: 1px solid #555; padding: 6px; border-radius: 3px; width: 100%; box-sizing: border-box; font-size: 13px; }
        
        input[type="range"] { width: 100%; margin: 5px 0; cursor: pointer; }
        input[type="checkbox"] { cursor: pointer; }
        
        .info-box { background: #111; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; color: #00E676; line-height: 1.5; margin-top: auto; border: 1px solid #333; white-space: pre-wrap; }
        .home-btn { position: absolute; top: 15px; left: 15px; text-decoration: none; background: #444; padding: 8px 15px; border-radius: 20px; color: #fff; font-weight: bold; font-size: 12px; border: 1px solid #666; z-index: 100; }
        
        #preview-tag { position: absolute; top: 10px; right: 10px; background: rgba(0, 229, 255, 0.8); color: #000; font-weight: bold; padding: 5px 10px; border-radius: 4px; font-size: 12px; display: none; pointer-events: none; z-index: 20; }
        #zoom-tag { position: absolute; bottom: 10px; right: 10px; background: rgba(0, 0, 0, 0.5); color: #fff; padding: 5px 10px; border-radius: 4px; font-size: 12px; pointer-events: none; z-index: 20; }
        
        #excluded-colors { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 5px; min-height: 5px;}
        .color-swatch { width: 20px; height: 20px; border-radius: 50%; border: 1px solid #fff; cursor: pointer; position: relative; }
        .color-swatch:hover::after { content: 'Ã—'; position: absolute; top:-2px; left:5px; color: red; font-weight: bold; }

        .status-msg { font-size: 12px; margin-top: 5px; padding: 5px; border-radius: 3px; display: none; text-align: center;}
        .success { background-color: #1b5e20; color: #a5d6a7; }
        .error { background-color: #b71c1c; color: #ef9a9a; }
        
        .template-section { background: #222; padding: 8px; border-radius: 5px; border: 1px solid #444; margin-bottom: 10px; }
    </style>
</head>
<body>

    <a href="#" class="home-btn" onclick="alert('ç¤ºç¯„é é¢')">ğŸ  å›é¦–é </a>
    <div id="preview-tag">ğŸ”µ é è¦½æ¨¡å¼ (S)</div>
    <div id="zoom-tag">100%</div>

    <div id="sidebar">
        <h2>ğŸ”¬ è† é«”åˆ†æ v4.0</h2>
        
        <h3>1. è¨­å®šæª”å­˜å– (Templates)</h3>
        <div class="template-section">
            <div class="control-row">
                <input type="text" id="templateNameInput" placeholder="è¼¸å…¥è¨­å®šåç¨± (ä¾‹: 10x-æ·±è‰²)">
            </div>
            <button onclick="saveCurrentSettings()" style="background-color:#00838F; color:white;">ğŸ’¾ å„²å­˜ç›®å‰è¨­å®š</button>
            <hr style="border:0; border-top:1px solid #444; margin: 8px 0;">
            <div class="control-row">
                <select id="templateSelect">
                    <option value="">-- é¸æ“‡è¨­å®šæª” --</option>
                </select>
                <button onclick="loadSelectedSettings()" style="width: 60px; background-color: #E65100;">è®€å–</button>
                <button onclick="refreshTemplateList()" style="width: 30px; padding:0;">â†»</button>
            </div>
            <div id="tplStatus" class="status-msg"></div>
        </div>

        <h3>2. æª”æ¡ˆèˆ‡å·¥å…·</h3>
        <button onclick="document.getElementById('fileInput').click()" style="background:#555;">ğŸ“‚ è¼‰å…¥åœ–ç‰‡</button>
        <input type="file" id="fileInput" accept="image/*" style="display: none;">
        
        <div class="btn-row">
            <button id="btnRect" onclick="setTool('rect')" class="active">â¬œ çŸ©å½¢</button>
            <button id="btnPoly" onclick="setTool('poly')">â¬¡ å¤šé‚Šå½¢</button>
        </div>
        
        <div class="control-row" style="background:#222; padding:5px; border-radius:4px; margin-top:5px;">
            <button id="btnSnap" class="toggle-snap" onclick="toggleSnap()" style="flex:1; margin:0;">ğŸ§² ç£æ€§å¸é™„</button>
            <div style="display:flex; align-items:center; gap:5px; margin-left:5px;">
                <input type="checkbox" id="chkShowEdges" onchange="toggleEdgeView()">
                <label for="chkShowEdges" style="cursor:pointer; font-size:11px;">é¡¯ç¤ºé‚Šç·£</label>
            </div>
        </div>
        
        <div style="display:flex; justify-content:space-between; font-size:11px; color:#aaa; margin-top:5px;">
            <span>æ»¾è¼ª: ç¸®æ”¾</span>
            <span>Shift+æ‹–æ›³: ç§»å‹•</span>
        </div>
        
        <div class="btn-row" style="margin-top:5px;">
            <button onclick="undo()" style="background:#666;">â†©ï¸ å¾©åŸ (Ctrl+Z)</button>
            <button onclick="resetROI()" style="background:#d32f2f;">ğŸ—‘ï¸ æ¸…é™¤</button>
        </div>

        <h3>3. é¡¯å¾®é¡æ ¡æ­£</h3>
        <div class="control-row">
            <button id="btnCalib" onclick="setTool('calib')" style="flex:1">ğŸ“ ç•«ç·šæ ¡æ­£</button>
            <label style="flex:0.2; text-align:right">1px=</label>
            <input type="number" id="pxRatio" readonly placeholder="--" style="width:70px; background:#222; color:#888">
        </div>
        <div style="font-size:11px; color:#aaa; text-align:center" id="scaleInfo">æœªæ ¡æ­£</div>

        <h3>4. å½±åƒåƒæ•¸</h3>
        <div class="control-row">
            <label>é€šé“:</label>
            <select id="channelSel" onchange="scheduleRender()">
                <option value="gray">ç°åº¦ (Gray)</option>
                <option value="r">ç´…è‰² (R)</option>
                <option value="g">ç¶ è‰² (G)</option>
                <option value="b">è—è‰² (B)</option>
            </select>
        </div>
        <div class="control-row">
            <div class="btn-row" style="flex:1;">
                <button id="btnDark" onclick="setMode('dark')" class="active" style="margin:0;">åµæ¸¬æ·±è‰²</button>
                <button id="btnLight" onclick="setMode('light')" style="margin:0;">åµæ¸¬äº®è‰²</button>
            </div>
        </div>

        <label>é–¾å€¼: <span id="threshVal" style="color:#4FC3F7">128</span></label>
        <input type="range" id="thresholdSlider" min="0" max="255" value="128" oninput="updateThreshold(this.value)">

        <div class="control-row" style="margin-top:5px;">
            <button id="btnPick" onclick="setTool('picker')" style="border:1px dashed #aaa; flex:1;">ğŸ’‰ å¸ç®¡å»è‰²</button>
            <input type="number" id="colorTol" value="30" min="0" max="255" title="å®¹è¨±åº¦" style="width:50px" onchange="scheduleRender()">
        </div>
        <div id="excluded-colors"></div>

        <button id="btnPreview" onclick="toggleBinaryPreview()" style="margin-top:10px; border:1px solid #555;">ğŸ‘ï¸ åˆ‡æ›é è¦½ (S)</button>

        <h3>5. è³‡æ–™èˆ‡è¼¸å‡º</h3>
        <div class="control-row">
            <input type="checkbox" id="chkShowOnCanvas" onchange="scheduleRender()" checked style="width:auto; margin-right:5px;">
            <label for="chkShowOnCanvas" style="cursor:pointer">çµæœé¡¯ç¤ºåœ¨å·¦ä¸Šè§’</label>
        </div>
        
        <button onclick="calculateArea()" class="action">â–¶ è¨ˆç®—é¢ç©</button>
        
        <div class="btn-row">
            <button onclick="saveAnalysis()" style="background-color: #1976D2;">ğŸ’¾ ä¸‹è¼‰åœ–ç‰‡</button>
            <button onclick="exportCSV()" style="background-color: #00796B;">ğŸ“Š åŒ¯å‡º CSV</button>
        </div>
        
        <button id="btnSaveDB" class="db-btn">â˜ï¸ å„²å­˜æ•¸æ“šåˆ° Firebase</button>
        <div id="dbStatus" class="status-msg"></div>

        <div class="info-box" id="resultBox">ç­‰å¾…è¨ˆç®—...</div>
    </div>

    <div id="main-area">
        <canvas id="displayCanvas"></canvas>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, addDoc, getDocs, query, orderBy, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        // ä½ çš„ Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyCnHhksuhJs9RdrL7DPnsAvR21ZND7kIOI",
            authDomain: "stack-diagram-db.firebaseapp.com",
            projectId: "stack-diagram-db",
            storageBucket: "stack-diagram-db.firebasestorage.app",
            messagingSenderId: "67240747982",
            appId: "1:67240747982:web:1fb065e40e936a7485419f",
            measurementId: "G-QJNE60W8BB"
        };

        // Initialize Firebase
        let db;
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            console.log("Firebase initialized");
            // åˆå§‹åŒ–æ™‚è®€å–è¨­å®šåˆ—è¡¨
            setTimeout(refreshTemplateList, 1000);
        } catch (error) {
            console.error("Firebase init error:", error);
            showStatus('tplStatus', "Firebase åˆå§‹åŒ–å¤±æ•—", "error");
        }

        // --- 1. å„²å­˜è¨­å®š (Templates) ---
        window.saveSettingsToDB = async function(name, settings) {
            if (!db) return alert("è³‡æ–™åº«æœªé€£ç·š");
            const statusDiv = document.getElementById('tplStatus');
            statusDiv.innerText = "å„²å­˜ä¸­...";
            statusDiv.style.display = 'block';
            statusDiv.className = 'status-msg';

            try {
                const docData = {
                    name: name,
                    settings: JSON.stringify(settings), // å°‡è¤‡é›œç‰©ä»¶è½‰å­—ä¸²å­˜æ¯”è¼ƒå®‰å…¨
                    timestamp: serverTimestamp()
                };
                await addDoc(collection(db, "analysis_templates"), docData);
                showStatus('tplStatus', "è¨­å®šæª”å·²å„²å­˜!", "success");
                refreshTemplateList();
            } catch (e) {
                console.error("Save Error:", e);
                showStatus('tplStatus', "å„²å­˜å¤±æ•—: " + e.message, "error");
            }
        };

        // --- 2. è®€å–è¨­å®šåˆ—è¡¨ ---
        window.refreshTemplateList = async function() {
            if (!db) return;
            const select = document.getElementById('templateSelect');
            // æ¸…ç©ºèˆŠé¸é … (ä¿ç•™ç¬¬ä¸€å€‹)
            while (select.options.length > 1) { select.remove(1); }

            try {
                const q = query(collection(db, "analysis_templates"), orderBy("timestamp", "desc"));
                const querySnapshot = await getDocs(q);
                
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const option = document.createElement("option");
                    option.value = JSON.stringify(data.settings); // æŠŠè¨­å®šç›´æ¥è—åœ¨ value
                    option.text = data.name + (data.timestamp ? ` (${new Date(data.timestamp.toDate()).toLocaleDateString()})` : "");
                    select.appendChild(option);
                });
            } catch (e) {
                console.error("Fetch Error:", e);
            }
        };

        // --- 3. å„²å­˜æ•¸æ“šçµæœ ---
        window.saveToFirestore = async function(data) {
            const statusDiv = document.getElementById('dbStatus');
            if (!db) {
                showStatus('dbStatus', "è³‡æ–™åº«æœªé€£ç·š", "error");
                return;
            }
            const btn = document.getElementById('btnSaveDB');
            btn.disabled = true;
            btn.textContent = "ä¸Šå‚³ä¸­...";

            try {
                data.timestamp = serverTimestamp();
                data.note = "Colloid Analysis Tool v4.0";
                await addDoc(collection(db, "colloid_analysis"), data);
                showStatus('dbStatus', "æ•¸æ“šå„²å­˜æˆåŠŸ!", "success");
            } catch (e) {
                showStatus('dbStatus', "å„²å­˜å¤±æ•—: " + e.message, "error");
            } finally {
                btn.disabled = false;
                btn.textContent = "â˜ï¸ å„²å­˜æ•¸æ“šåˆ° Firebase";
            }
        };

        function showStatus(id, msg, type) {
            const el = document.getElementById(id);
            el.innerText = msg;
            el.className = "status-msg " + type;
            el.style.display = 'block';
            setTimeout(() => { el.style.display = 'none'; }, 3000);
        }
    </script>

    <script>
        // --- 1. å…¨åŸŸè®Šæ•¸å®šç¾© ---
        const mainArea = document.getElementById('main-area');
        const canvas = document.getElementById('displayCanvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');

        // å½±åƒç·©è¡å€
        let img = new Image();
        let offscreenCanvas = document.createElement('canvas'); // åŸå§‹åœ–
        let offCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
        
        let processedCanvas = document.createElement('canvas'); // é è¦½åœ–
        let procCtx = processedCanvas.getContext('2d');
        
        let edgeCanvas = document.createElement('canvas'); // é‚Šç·£åœ– (è¦–è¦ºåŒ–ç”¨)
        let edgeCtx = edgeCanvas.getContext('2d');
        
        let currentFileName = "analysis";

        // æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹
        let appState = {
            tool: 'rect',          
            mode: 'dark',          
            threshold: 128,
            pxPerMm: 0,
            excludedColors: [],
            isSnapEnabled: false,
            isShowEdges: false,    // æ–°å¢ï¼šæ˜¯å¦é¡¯ç¤ºé‚Šç·£
            isPreviewing: false,
            polyPoints: [],        
            roiMask: null,         
            calibLine: null,       
            
            // è¦–åœ–è®Šæ›
            view: { scale: 1, x: 0, y: 0 },
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            
            // æ»‘é¼ ç‹€æ…‹
            isDrawing: false,
            snapPos: null,         
            mousePos: {x:0, y:0},

            // åˆ†æçµæœ
            lastResult: null
        };

        // --- 2. ç³»çµ±åˆå§‹åŒ–èˆ‡äº‹ä»¶ç¶å®š ---
        
        window.addEventListener('resize', resizeCanvas);
        
        fileInput.addEventListener('change', function(e) {
            if (e.target.files && e.target.files[0]) {
                currentFileName = e.target.files[0].name;
                let reader = new FileReader();
                reader.onload = function(evt) {
                    img.onload = function() {
                        const w = img.width;
                        const h = img.height;
                        offscreenCanvas.width = w; offscreenCanvas.height = h;
                        offCtx.drawImage(img, 0, 0);
                        
                        processedCanvas.width = w; processedCanvas.height = h;
                        edgeCanvas.width = w; edgeCanvas.height = h;
                        
                        // é‡ç½®
                        appState.roiMask = null;
                        appState.polyPoints = [];
                        appState.calibLine = null;
                        appState.lastResult = null;
                        
                        // ç”¢ç”Ÿé‚Šç·£åœ–
                        generateEdgeView();

                        resizeCanvas();
                        fitImageToScreen();
                        scheduleRender();
                    }
                    img.src = evt.target.result;
                }
                reader.readAsDataURL(e.target.files[0]);
            }
        });

        function resizeCanvas() {
            canvas.width = mainArea.clientWidth;
            canvas.height = mainArea.clientHeight;
            scheduleRender();
        }

        function fitImageToScreen() {
            if (!img.width) return;
            const scaleX = (canvas.width * 0.95) / img.width;
            const scaleY = (canvas.height * 0.95) / img.height;
            appState.view.scale = Math.min(scaleX, scaleY);
            appState.view.x = (canvas.width - img.width * appState.view.scale) / 2;
            appState.view.y = (canvas.height - img.height * appState.view.scale) / 2;
            updateZoomUI();
        }

        // --- 3. è¨­å®šå­˜å–é‚è¼¯ (Local) ---
        window.saveCurrentSettings = function() {
            const name = document.getElementById('templateNameInput').value;
            if(!name) return alert("è«‹è¼¸å…¥è¨­å®šæª”åç¨±");
            
            const settings = {
                threshold: appState.threshold,
                mode: appState.mode,
                pxPerMm: appState.pxPerMm,
                excludedColors: appState.excludedColors,
                channel: document.getElementById('channelSel').value,
                roiMask: appState.roiMask // åŒ…å« ROI ä½ç½®
            };
            
            if(window.saveSettingsToDB) {
                // å°‡ç‰©ä»¶è½‰æˆ JSON å­—ä¸²å„²å­˜
                window.saveSettingsToDB(name, JSON.stringify(settings));
            }
        }

        window.loadSelectedSettings = function() {
            const select = document.getElementById('templateSelect');
            const val = select.value;
            if(!val) return alert("è«‹é¸æ“‡ä¸€å€‹è¨­å®šæª”");
            
            try {
                // Firebase å‚³å›ä¾†çš„æ˜¯å·²ç¶“ stringify éå…©æ¬¡çš„ (ä¸€æ¬¡æ˜¯æˆ‘å­˜çš„ï¼Œä¸€æ¬¡æ˜¯ option value)
                // ä½†é€™è£¡ option value å·²ç¶“æ˜¯ stringï¼Œæˆ‘å€‘éœ€è¦ parse ä¸€æ¬¡è¨­å®šå…§å®¹
                // å¦‚æœå­˜çš„æ™‚å€™æ˜¯ JSON.stringify(settings)ï¼Œé‚£å–å‡ºä¾†çš„ val å°±æ˜¯é‚£å€‹ JSON å­—ä¸²
                // é‚„åŸï¼š
                let rawSettings = JSON.parse(val); 
                // æ³¨æ„ï¼šå¦‚æœä¹‹å‰å­˜çš„æ™‚å€™å¤šäº†ä¸€å±¤ stringifyï¼Œå¯èƒ½è¦ parse å…©æ¬¡ï¼Œä½†æˆ‘å€‘ä¸Šé¢ logic æ˜¯ä¸€æ¬¡
                // ç‚ºäº†ä¿éšªï¼Œå¦‚æœæ˜¯ string å°±å† parse ä¸€æ¬¡
                let settings = (typeof rawSettings === 'string') ? JSON.parse(rawSettings) : rawSettings;

                // æ‡‰ç”¨è¨­å®š
                if(settings.threshold !== undefined) {
                    appState.threshold = settings.threshold;
                    document.getElementById('thresholdSlider').value = settings.threshold;
                    document.getElementById('threshVal').innerText = settings.threshold;
                }
                if(settings.mode) {
                    setMode(settings.mode);
                }
                if(settings.pxPerMm) {
                    appState.pxPerMm = settings.pxPerMm;
                    document.getElementById('scaleInfo').innerText = "å·²æ ¡æ­£ (è®€å–)";
                    document.getElementById('pxRatio').value = (1/appState.pxPerMm).toFixed(5);
                }
                if(settings.excludedColors) {
                    appState.excludedColors = settings.excludedColors;
                    renderExcludedColorsUI();
                }
                if(settings.channel) {
                    document.getElementById('channelSel').value = settings.channel;
                }
                if(settings.roiMask) {
                    appState.roiMask = settings.roiMask;
                }

                alert("è¨­å®šå·²è®€å–ä¸¦å¥—ç”¨ï¼");
                if(appState.isPreviewing) updateProcessedBuffer();
                scheduleRender();

            } catch(e) {
                console.error(e);
                alert("è®€å–è¨­å®šå¤±æ•—: " + e.message);
            }
        }

        // --- 4. UI äº’å‹•å‡½å¼ ---

        window.setTool = function(toolName) {
            appState.tool = toolName;
            document.querySelectorAll('.btn-row button, .control-row button').forEach(b => b.classList.remove('active'));
            const map = { 'rect': 'btnRect', 'poly': 'btnPoly', 'calib': 'btnCalib', 'picker': 'btnPick' };
            if(map[toolName]) document.getElementById(map[toolName]).classList.add('active');
            
            document.getElementById('btnDark').classList.toggle('active', appState.mode === 'dark');
            document.getElementById('btnLight').classList.toggle('active', appState.mode === 'light');

            appState.isDrawing = false;
            if(toolName !== 'poly') appState.polyPoints = [];
            scheduleRender();
        }

        window.setMode = function(modeName) {
            appState.mode = modeName;
            window.setTool(appState.tool);
            if(appState.isPreviewing) updateProcessedBuffer();
            scheduleRender();
        }

        window.toggleSnap = function() {
            appState.isSnapEnabled = !appState.isSnapEnabled;
            const btn = document.getElementById('btnSnap');
            btn.classList.toggle('active', appState.isSnapEnabled);
            btn.innerText = appState.isSnapEnabled ? "ğŸ§² ç£æ€§å¸é™„ (é–‹)" : "ğŸ§² ç£æ€§å¸é™„ (é—œ)";
            scheduleRender();
        }

        window.toggleEdgeView = function() {
            appState.isShowEdges = document.getElementById('chkShowEdges').checked;
            scheduleRender();
        }

        window.toggleBinaryPreview = function() {
            if(!img.src) return;
            appState.isPreviewing = !appState.isPreviewing;
            document.getElementById('preview-tag').style.display = appState.isPreviewing ? 'block' : 'none';
            document.getElementById('btnPreview').classList.toggle('active', appState.isPreviewing);
            if(appState.isPreviewing) updateProcessedBuffer();
            scheduleRender();
        }

        window.resetROI = function() {
            if(confirm("ç¢ºå®šæ¸…é™¤é¸å–ç¯„åœå—ï¼Ÿ")) {
                appState.roiMask = null;
                appState.polyPoints = [];
                appState.lastResult = null;
                document.getElementById('resultBox').innerText = "å€åŸŸå·²é‡ç½®";
                scheduleRender();
            }
        }

        window.undo = function() {
            if (appState.tool === 'poly' && appState.polyPoints.length > 0) {
                appState.polyPoints.pop();
            } else if (appState.roiMask) {
                appState.roiMask = null;
                appState.lastResult = null;
            }
            scheduleRender();
        }

        window.updateThreshold = function(val) {
            appState.threshold = parseInt(val);
            document.getElementById('threshVal').innerText = val;
            if(appState.isPreviewing) {
                updateProcessedBuffer();
                scheduleRender();
            }
        }

        // --- 5. é‚Šç·£åµæ¸¬èˆ‡è¦–è¦ºåŒ– (æ ¸å¿ƒæ–°å¢) ---
        
        function generateEdgeView() {
            if(!img.width) return;
            const w = img.width;
            const h = img.height;
            const srcData = offCtx.getImageData(0,0,w,h).data;
            const edgeImg = edgeCtx.createImageData(w,h);
            const dst = edgeImg.data;
            const stride = w * 4;

            // ç°¡å–®çš„ Sobel æ¿¾æ³¢ï¼ŒæŠŠçµæœç•«æˆæ´‹ç´…è‰²
            for(let y=1; y<h-1; y++) {
                for(let x=1; x<w-1; x++) {
                    const i = (y * w + x) * 4;
                    // ä½¿ç”¨ç¶ è‰²é€šé“è¨ˆç®—æ¢¯åº¦
                    const gx = Math.abs(srcData[i+1+4] - srcData[i+1-4]);
                    const gy = Math.abs(srcData[i+1+stride] - srcData[i+1-stride]);
                    const grad = gx + gy;

                    if (grad > 30) { // é‚Šç·£é–¾å€¼
                        dst[i] = 255;   // R
                        dst[i+1] = 0;   // G
                        dst[i+2] = 255; // B -> Magenta
                        dst[i+3] = 255; // Alpha
                    } else {
                        dst[i+3] = 0;   // é€æ˜
                    }
                }
            }
            edgeCtx.putImageData(edgeImg, 0, 0);
        }

        function findStrongestEdge(imgX, imgY) {
            if(!img.width) return {x: imgX, y: imgY};
            const radius = 15;
            const sx = Math.max(0, Math.floor(imgX - radius));
            const sy = Math.max(0, Math.floor(imgY - radius));
            const w = Math.min(img.width - sx, radius * 2);
            const h = Math.min(img.height - sy, radius * 2);
            
            if(w<=0 || h<=0) return {x: imgX, y: imgY};

            const imgData = offCtx.getImageData(sx, sy, w, h);
            const data = imgData.data;
            const stride = imgData.width * 4;

            let maxGrad = -1;
            let bestX = imgX, bestY = imgY;

            for(let y=1; y<h-1; y++) {
                for(let x=1; x<w-1; x++) {
                    const i = (y * imgData.width + x) * 4;
                    const gx = Math.abs(data[i+1+4] - data[i+1-4]);
                    const gy = Math.abs(data[i+1+stride] - data[i+1-stride]);
                    const grad = gx + gy;
                    const dist = Math.sqrt(Math.pow(x - (imgX-sx), 2) + Math.pow(y - (imgY-sy), 2));
                    const score = grad - (dist * 3); 

                    if(score > maxGrad && grad > 20) { 
                        maxGrad = score;
                        bestX = sx + x;
                        bestY = sy + y;
                    }
                }
            }
            return (maxGrad > 0) ? {x: bestX, y: bestY} : {x: imgX, y: imgY};
        }

        // --- 6. Canvas äº‹ä»¶è™•ç† ---

        function screenToImage(sx, sy) {
            return {
                x: (sx - appState.view.x) / appState.view.scale,
                y: (sy - appState.view.y) / appState.view.scale
            };
        }

        canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            if(!img.src) return;
            const zoomIntensity = 0.1;
            const direction = e.deltaY < 0 ? 1 : -1;
            const factor = (direction > 0) ? (1 + zoomIntensity) : (1 - zoomIntensity);
            const mouseImg = screenToImage(e.offsetX, e.offsetY);
            let newScale = appState.view.scale * factor;
            newScale = Math.max(0.01, Math.min(newScale, 50)); 
            appState.view.x = e.offsetX - mouseImg.x * newScale;
            appState.view.y = e.offsetY - mouseImg.y * newScale;
            appState.view.scale = newScale;
            updateZoomUI();
            scheduleRender();
        }, { passive: false });

        function updateZoomUI() {
            document.getElementById('zoom-tag').innerText = Math.round(appState.view.scale * 100) + "%";
        }

        canvas.addEventListener('mousedown', function(e) {
            if(!img.src) return;
            const p = screenToImage(e.offsetX, e.offsetY);

            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                appState.isDragging = true;
                appState.dragStart = { x: e.offsetX, y: e.offsetY };
                canvas.style.cursor = 'grabbing';
                return;
            }

            if (appState.tool === 'picker') {
                const pixel = offCtx.getImageData(p.x, p.y, 1, 1).data;
                addExcludedColor(pixel[0], pixel[1], pixel[2]);
                return;
            }

            if (appState.tool === 'calib') {
                appState.isDrawing = true;
                appState.calibLine = { x1: p.x, y1: p.y, x2: p.x, y2: p.y };
                return;
            }

            let finalP = (appState.isSnapEnabled && appState.snapPos) ? appState.snapPos : p;

            if (appState.tool === 'rect') {
                appState.isDrawing = true;
                appState.roiMask = { type: 'rect', startX: finalP.x, startY: finalP.y, x: finalP.x, y: finalP.y, w: 0, h: 0 };
                appState.lastResult = null; 
            } else if (appState.tool === 'poly') {
                if(appState.roiMask && appState.roiMask.type !== 'poly') {
                    appState.roiMask = null;
                    appState.polyPoints = [];
                    appState.lastResult = null;
                }
                if (appState.polyPoints.length > 2) {
                    const startPt = appState.polyPoints[0];
                    const distImg = Math.sqrt(Math.pow(finalP.x - startPt.x, 2) + Math.pow(finalP.y - startPt.y, 2));
                    const distScreen = distImg * appState.view.scale;
                    
                    if (distScreen < 20) { 
                        appState.roiMask = { type: 'poly', points: [...appState.polyPoints] };
                        appState.polyPoints = []; 
                        if(appState.isPreviewing) updateProcessedBuffer();
                        scheduleRender();
                        return;
                    }
                }
                appState.polyPoints.push(finalP);
                scheduleRender();
            }
        });

        canvas.addEventListener('mousemove', function(e) {
            if(!img.src) return;
            if (appState.isDragging) {
                const dx = e.offsetX - appState.dragStart.x;
                const dy = e.offsetY - appState.dragStart.y;
                appState.view.x += dx;
                appState.view.y += dy;
                appState.dragStart = { x: e.offsetX, y: e.offsetY };
                scheduleRender();
                return;
            }

            const p = screenToImage(e.offsetX, e.offsetY);
            appState.mousePos = p; 

            if (appState.isSnapEnabled && !appState.isDrawing) {
                appState.snapPos = findStrongestEdge(p.x, p.y);
            } else {
                appState.snapPos = null;
            }

            if (appState.isDrawing) {
                const targetP = (appState.isSnapEnabled && appState.snapPos) ? appState.snapPos : p;
                
                if (appState.tool === 'rect') {
                    let w = targetP.x - appState.roiMask.startX;
                    let h = targetP.y - appState.roiMask.startY;
                    appState.roiMask.x = w < 0 ? targetP.x : appState.roiMask.startX;
                    appState.roiMask.y = h < 0 ? targetP.y : appState.roiMask.startY;
                    appState.roiMask.w = Math.abs(w);
                    appState.roiMask.h = Math.abs(h);
                } else if (appState.tool === 'calib') {
                    appState.calibLine.x2 = targetP.x;
                    appState.calibLine.y2 = targetP.y;
                }
            }
            scheduleRender();
        });

        canvas.addEventListener('mouseup', function(e) {
            appState.isDragging = false;
            canvas.style.cursor = 'crosshair';

            if (appState.isDrawing) {
                appState.isDrawing = false;
                if (appState.tool === 'calib' && appState.calibLine) {
                    const dx = appState.calibLine.x2 - appState.calibLine.x1;
                    const dy = appState.calibLine.y2 - appState.calibLine.y1;
                    const distPx = Math.sqrt(dx*dx + dy*dy);
                    
                    setTimeout(() => {
                        const realMm = prompt("é€™æ®µé•·åº¦æ˜¯å¤šå°‘ mmï¼Ÿ", "1");
                        if(realMm && !isNaN(realMm)) {
                            appState.pxPerMm = distPx / parseFloat(realMm);
                            document.getElementById('scaleInfo').innerText = "å·²æ ¡æ­£";
                            document.getElementById('pxRatio').value = (1/appState.pxPerMm).toFixed(5);
                        } else {
                            appState.calibLine = null;
                        }
                        scheduleRender();
                    }, 50);
                }
            }
        });
        
        window.addEventListener('keydown', (e) => {
            if((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }
            const tag = document.activeElement.tagName;
            if (e.key === 's' || e.key === 'S') {
                if (tag !== 'INPUT' && tag !== 'TEXTAREA') {
                    toggleBinaryPreview();
                }
            }
        });

        // --- 7. æ¸²æŸ“å¼•æ“ ---
        let renderReq = null;
        window.scheduleRender = function() {
            if(renderReq) cancelAnimationFrame(renderReq);
            renderReq = requestAnimationFrame(render);
        }

        function render() {
            ctx.fillStyle = "#333";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if(!img.src) {
                ctx.fillStyle = "#666";
                ctx.font = "20px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("è«‹å…ˆè¼‰å…¥åœ–ç‰‡", canvas.width/2, canvas.height/2);
                return;
            }

            ctx.save();
            ctx.translate(appState.view.x, appState.view.y);
            ctx.scale(appState.view.scale, appState.view.scale);

            // 1. ç•«åº•åœ–
            if (appState.isPreviewing) {
                ctx.drawImage(processedCanvas, 0, 0);
            } else {
                ctx.drawImage(offscreenCanvas, 0, 0);
            }
            
            // 2. ç•«é‚Šç·£è¼”åŠ©ç·š (æ–°å¢)
            if (appState.isShowEdges && !appState.isPreviewing) {
                ctx.globalAlpha = 0.8;
                ctx.drawImage(edgeCanvas, 0, 0);
                ctx.globalAlpha = 1.0;
            }

            const lineWidth = 2 / appState.view.scale;
            const ptSize = 4 / appState.view.scale;

            // 3. ç•« ROI
            if (appState.roiMask) {
                ctx.strokeStyle = '#FFFF00'; 
                ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                if (appState.roiMask.type === 'rect') {
                    ctx.rect(appState.roiMask.x, appState.roiMask.y, appState.roiMask.w, appState.roiMask.h);
                } else {
                    const pts = appState.roiMask.points;
                    ctx.moveTo(pts[0].x, pts[0].y);
                    for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
                    ctx.closePath();
                }
                ctx.fill();
                ctx.stroke();
            }

            // 4. ç•« Poly (é€²è¡Œä¸­)
            if (appState.tool === 'poly' && appState.polyPoints.length > 0) {
                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                const pts = appState.polyPoints;
                ctx.moveTo(pts[0].x, pts[0].y);
                for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
                
                let target = (appState.isSnapEnabled && appState.snapPos) ? appState.snapPos : appState.mousePos;
                ctx.lineTo(target.x, target.y);
                ctx.stroke();

                ctx.fillStyle = '#00FF00';
                for(let p of pts) {
                    ctx.beginPath(); ctx.arc(p.x, p.y, ptSize, 0, Math.PI*2); ctx.fill();
                }

                const startPt = pts[0];
                const dist = Math.sqrt(Math.pow(target.x - startPt.x, 2) + Math.pow(target.y - startPt.y, 2));
                if (dist * appState.view.scale < 20 && pts.length > 2) {
                    ctx.strokeStyle = 'white';
                    ctx.fillStyle = 'rgba(255,0,0,0.5)';
                    ctx.beginPath(); 
                    ctx.arc(startPt.x, startPt.y, ptSize * 3, 0, Math.PI*2); 
                    ctx.fill(); ctx.stroke();
                }
            }

            // 5. ç•«å¸é™„
            if (appState.isSnapEnabled && appState.snapPos && (appState.tool==='rect' || appState.tool==='poly')) {
                ctx.strokeStyle = '#FF0055';
                ctx.lineWidth = lineWidth;
                const r = 10 / appState.view.scale;
                ctx.beginPath(); ctx.arc(appState.snapPos.x, appState.snapPos.y, r, 0, Math.PI*2); ctx.stroke();
                ctx.beginPath(); 
                ctx.moveTo(appState.snapPos.x-r, appState.snapPos.y); ctx.lineTo(appState.snapPos.x+r, appState.snapPos.y);
                ctx.moveTo(appState.snapPos.x, appState.snapPos.y-r); ctx.lineTo(appState.snapPos.x, appState.snapPos.y+r);
                ctx.stroke();
            }

            // 6. ç•«æ ¡æ­£ç·š
            if (appState.calibLine) {
                ctx.strokeStyle = '#00B0FF';
                ctx.lineWidth = lineWidth;
                const l = appState.calibLine;
                ctx.beginPath(); ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2); ctx.stroke();
                ctx.fillStyle = '#00B0FF';
                ctx.beginPath(); ctx.arc(l.x1, l.y1, ptSize, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(l.x2, l.y2, ptSize, 0, Math.PI*2); ctx.fill();
            }

            ctx.restore();

            // 7. çµæœé¡¯ç¤º (Overlay)
            const showOnCanvas = document.getElementById('chkShowOnCanvas').checked;
            if (appState.lastResult && showOnCanvas) {
                const fontSize = 20;
                ctx.font = `bold ${fontSize}px "Microsoft JhengHei"`;
                
                let lines = [
                    `ROI: ${appState.lastResult.roiDisplay}`,
                    `è† é«”: ${appState.lastResult.glueDisplay}`,
                    `ä½”æ¯”: ${appState.lastResult.percentage}%`
                ];

                const padding = 15;
                const lineHeight = fontSize * 1.5;
                let maxWidth = 0;
                lines.forEach(l => {
                    const w = ctx.measureText(l).width;
                    if(w > maxWidth) maxWidth = w;
                });

                const startX = 20;
                const startY = 20;
                ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
                ctx.fillRect(startX, startY, maxWidth + padding*2, (lines.length * lineHeight) + padding);
                
                ctx.textBaseline = "top";
                ctx.fillStyle = "#00E5FF"; 
                lines.forEach((l, i) => {
                   ctx.fillText(l, startX + padding, startY + padding/2 + (i * lineHeight));
                });
            }
        }

        // --- 8. å½±åƒè¨ˆç®—èˆ‡è¼¸å‡º ---
        
        function addExcludedColor(r, g, b) {
            appState.excludedColors.push({r, g, b});
            renderExcludedColorsUI();
            if(appState.isPreviewing) updateProcessedBuffer();
            scheduleRender();
        }

        function renderExcludedColorsUI() {
            const div = document.getElementById('excluded-colors');
            div.innerHTML = '';
            appState.excludedColors.forEach((c, idx) => {
                const s = document.createElement('div');
                s.className = 'color-swatch';
                s.style.backgroundColor = `rgb(${c.r},${c.g},${c.b})`;
                s.onclick = () => {
                    appState.excludedColors.splice(idx, 1);
                    renderExcludedColorsUI();
                    if(appState.isPreviewing) updateProcessedBuffer();
                    scheduleRender();
                };
                div.appendChild(s);
            });
        }

        function updateProcessedBuffer() {
            const w = img.width, h = img.height;
            const src = offCtx.getImageData(0,0,w,h).data;
            const dstImg = procCtx.createImageData(w,h);
            const dst = dstImg.data;
            
            const chan = document.getElementById('channelSel').value;
            const tol = parseInt(document.getElementById('colorTol').value);
            
            for(let i=0; i<src.length; i+=4) {
                const r=src[i], g=src[i+1], b=src[i+2];
                
                let isExcluded = false;
                for(let ec of appState.excludedColors) {
                    if(Math.abs(r-ec.r)+Math.abs(g-ec.g)+Math.abs(b-ec.b) < tol*2) {
                        isExcluded = true; break;
                    }
                }
                if(isExcluded) {
                    dst[i]=100; dst[i+1]=0; dst[i+2]=100; dst[i+3]=255; continue;
                }

                let val = 0;
                if(chan==='gray') val = 0.299*r+0.587*g+0.114*b;
                else if(chan==='r') val = r;
                else if(chan==='g') val = g;
                else if(chan==='b') val = b;

                let isTarget = (appState.mode==='dark') ? (val < appState.threshold) : (val > appState.threshold);
                
                if(isTarget) {
                    dst[i]=0; dst[i+1]=255; dst[i+2]=255; dst[i+3]=255; // Cyan
                } else {
                    const gray = val * 0.4;
                    dst[i]=gray; dst[i+1]=gray; dst[i+2]=gray; dst[i+3]=255;
                }
            }
            procCtx.putImageData(dstImg, 0, 0);
        }

        window.calculateArea = function() {
            if(!img.src || !appState.roiMask) { alert("è«‹å…ˆé¸å–å€åŸŸ"); return; }

            const mCv = document.createElement('canvas'); mCv.width = img.width; mCv.height = img.height;
            const mCtx = mCv.getContext('2d');
            mCtx.fillStyle = 'white'; mCtx.beginPath();
            
            if(appState.roiMask.type==='rect') {
                mCtx.rect(appState.roiMask.x, appState.roiMask.y, appState.roiMask.w, appState.roiMask.h);
            } else {
                const pts = appState.roiMask.points;
                mCtx.moveTo(pts[0].x, pts[0].y);
                for(let i=1; i<pts.length; i++) mCtx.lineTo(pts[i].x, pts[i].y);
                mCtx.closePath();
            }
            mCtx.fill();
            
            const maskData = mCtx.getImageData(0,0,img.width,img.height).data;
            const srcData = offCtx.getImageData(0,0,img.width,img.height).data;
            
            let roiPx = 0, gluePx = 0;
            const chan = document.getElementById('channelSel').value;
            const tol = parseInt(document.getElementById('colorTol').value);

            const visImg = procCtx.createImageData(img.width, img.height);
            const vis = visImg.data;

            for(let i=0; i<srcData.length; i+=4) {
                vis[i]=srcData[i]; vis[i+1]=srcData[i+1]; vis[i+2]=srcData[i+2]; vis[i+3]=255;

                if(maskData[i+3] > 0) { 
                    roiPx++;
                    const r=srcData[i], g=srcData[i+1], b=srcData[i+2];

                    let isExcluded = false;
                    for(let ec of appState.excludedColors) {
                        if(Math.abs(r-ec.r)+Math.abs(g-ec.g)+Math.abs(b-ec.b) < tol*2) {
                            isExcluded = true; break;
                        }
                    }

                    if(!isExcluded) {
                        let val = 0;
                        if(chan==='gray') val = 0.299*r+0.587*g+0.114*b;
                        else if(chan==='r') val = r;
                        else if(chan==='g') val = g;
                        else if(chan==='b') val = b;

                        let isTarget = (appState.mode==='dark') ? (val < appState.threshold) : (val > appState.threshold);
                        if(isTarget) {
                            gluePx++;
                            vis[i]=0; vis[i+1]=200; vis[i+2]=200; // Cyan Result
                        }
                    }
                }
            }
            procCtx.putImageData(visImg, 0, 0);
            
            appState.isPreviewing = true;
            document.getElementById('preview-tag').style.display = 'block';
            document.getElementById('btnPreview').classList.add('active');
            
            // è¨ˆç®—æ•¸æ“š
            const percent = roiPx>0 ? ((gluePx/roiPx)*100).toFixed(2) : "0.00";
            let roiDisplay = `${roiPx} pxÂ²`;
            let glueDisplay = `${gluePx} pxÂ²`;
            
            if(appState.pxPerMm > 0) {
                const rMm = (roiPx / (appState.pxPerMm**2)).toFixed(4);
                const gMm = (gluePx / (appState.pxPerMm**2)).toFixed(4);
                roiDisplay += ` (${rMm} mmÂ²)`;
                glueDisplay += ` (${gMm} mmÂ²)`;
            }

            appState.lastResult = {
                roiPx, gluePx, percent, roiDisplay, glueDisplay, percentage: percent
            };

            scheduleRender(); 
            const report = `ROI: ${roiDisplay}<br>è† é«”: ${glueDisplay}`;
            document.getElementById('resultBox').innerHTML = `${report}<br>æ¯”ä¾‹: <span style="color:cyan; font-size:16px;">${percent}%</span>`;
        }

        // --- 9. å„²å­˜èˆ‡åŒ¯å‡º ---

        document.getElementById('btnSaveDB').addEventListener('click', () => {
            if(!appState.lastResult) {
                alert("è«‹å…ˆè¨ˆç®—é¢ç© (æŒ‰ä¸‹ â–¶ è¨ˆç®—é¢ç©)");
                return;
            }
            if(window.saveToFirestore) {
                const data = {
                    fileName: currentFileName,
                    roiPixels: appState.lastResult.roiPx,
                    gluePixels: appState.lastResult.gluePx,
                    percentage: appState.lastResult.percent,
                    isCalibrated: (appState.pxPerMm > 0),
                    pxPerMm: appState.pxPerMm || 0
                };
                window.saveToFirestore(data);
            }
        });

        window.saveAnalysis = function() {
            if(!img.src) return;
            scheduleRender();
            setTimeout(() => {
                const link = document.createElement('a');
                link.download = `analysis_${currentFileName}`;
                link.href = canvas.toDataURL('image/jpeg', 0.9);
                link.click();
            }, 100);
        }

        window.exportCSV = function() {
            if(!appState.lastResult) { alert("ç„¡æ•¸æ“šå¯åŒ¯å‡º"); return; }
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "FileName,ROI_Pixels,Glue_Pixels,Percentage,IsCalibrated\n";
            csvContent += `${currentFileName},${appState.lastResult.roiPx},${appState.lastResult.gluePx},${appState.lastResult.percent},${appState.pxPerMm > 0}`;
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "analysis_data.csv");
            document.body.appendChild(link);
            link.click();
        }

    </script>
</body>
</html>
