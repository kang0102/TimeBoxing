<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è† é«”åˆ†æå·¥å…· v2.4 (æ•ˆèƒ½å„ªåŒ–ç‰ˆ)</title>
    <style>
        /* --- åŸºç¤ä½ˆå±€ --- */
        body { font-family: "Microsoft JhengHei", Arial, sans-serif; background-color: #1e1e1e; color: #ddd; margin: 0; display: flex; height: 100vh; overflow: hidden; }
        
        #sidebar { width: 300px; background-color: #2b2b2b; padding: 15px; padding-top: 60px; display: flex; flex-direction: column; gap: 8px; box-shadow: 2px 0 5px rgba(0,0,0,0.5); z-index: 10; overflow-y: auto; }
        #main-area { flex-grow: 1; position: relative; background-color: #333; overflow: hidden; display: flex; justify-content: center; align-items: center; }
        canvas { box-shadow: 0 0 20px rgba(0,0,0,0.5); max-width: 95%; max-height: 95%; cursor: crosshair; }

        h2 { margin: 0 0 10px 0; color: #00E5FF; font-size: 18px; }
        h3 { margin: 15px 0 5px 0; color: #aaa; font-size: 13px; border-bottom: 1px solid #444; padding-bottom: 2px; text-transform: uppercase; letter-spacing: 1px;}
        
        button { padding: 8px; font-size: 13px; cursor: pointer; background-color: #444; color: white; border: 1px solid #555; border-radius: 4px; transition: 0.2s; width: 100%; text-align: center; margin-bottom: 2px;}
        button:hover { background-color: #666; }
        button.active { background-color: #00897B; border-color: #00695C; font-weight: bold; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
        button.action { background-color: #388E3C; border-color: #2E7D32; font-weight: bold; font-size: 14px; padding: 10px; margin-top: 10px;}
        
        .btn-row { display: flex; gap: 5px; }
        .btn-cloud { background-color: #FF9800; border-color: #F57C00; color: black; font-weight: bold; }

        .control-row { display: flex; gap: 5px; align-items: center; margin-bottom: 5px; }
        .control-row label { flex: 1; font-size: 12px; color: #ccc; }
        select, input[type="number"], input[type="text"] { background: #333; color: white; border: 1px solid #555; padding: 4px; border-radius: 3px; width: 100%; box-sizing: border-box; }
        input[type="number"] { width: 70px; }

        input[type="range"] { width: 100%; margin: 5px 0; cursor: pointer; }
        
        .info-box { background: #111; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; color: #00E676; line-height: 1.5; margin-top: auto; border: 1px solid #333; white-space: pre-wrap; }
        .home-btn { position: absolute; top: 15px; left: 15px; text-decoration: none; background: #444; padding: 8px 15px; border-radius: 20px; color: #fff; font-weight: bold; font-size: 12px; border: 1px solid #666; z-index: 100; }
        
        #preview-tag { position: absolute; top: 10px; right: 10px; background: rgba(0, 229, 255, 0.8); color: #000; font-weight: bold; padding: 5px 10px; border-radius: 4px; font-size: 12px; display: none; pointer-events: none; }
        
        #excluded-colors { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 5px; min-height: 5px;}
        .color-swatch { width: 20px; height: 20px; border-radius: 50%; border: 1px solid #fff; cursor: pointer; position: relative; }
        .color-swatch:hover::after { content: 'Ã—'; position: absolute; top:-2px; left:5px; color: red; font-weight: bold; }
    </style>
</head>
<body>

    <a href="./" class="home-btn">ğŸ  å›é¦–é </a>
    <div id="preview-tag">ğŸ”µ é è¦½æ¨¡å¼</div>

    <div id="sidebar">
        <h2>ğŸ”¬ è† é«”åˆ†æ v2.4</h2>
        
        <div style="background: rgba(255,152,0,0.1); padding: 8px; border-radius: 6px; border: 1px solid #FF9800; margin-bottom: 5px;">
            <div style="display:flex; gap:5px;">
                <select id="cloud-settings" onchange="loadFromCloud()" style="flex:1;">
                    <option value="">-- è®€å–é›²ç«¯åƒæ•¸ --</option>
                </select>
                <button onclick="deleteFromCloud()" style="width:30px; padding:0; background:#d32f2f;">ğŸ—‘ï¸</button>
            </div>
            <div style="display:flex; gap:5px; margin-top:5px;">
                <input type="text" id="setting-name" placeholder="è¨­å®šæª”åç¨±...">
                <button class="btn-cloud" onclick="saveToCloud()" style="width:60px;">å„²å­˜</button>
            </div>
        </div>

        <h3>1. æª”æ¡ˆèˆ‡å·¥å…·</h3>
        <button onclick="document.getElementById('fileInput').click()" style="background:#555;">ğŸ“‚ è¼‰å…¥åœ–ç‰‡</button>
        <input type="file" id="fileInput" accept="image/*" style="display: none;" onchange="loadImage(this)">
        
        <div class="btn-row">
            <button id="btnRect" onclick="setTool('rect')" class="active">â¬œ çŸ©å½¢é¸å–</button>
            <button id="btnPoly" onclick="setTool('poly')">â¬¡ å¤šé‚Šå½¢</button>
        </div>
        <button onclick="resetROI()" style="background:#d32f2f; margin-top:2px;">ğŸ—‘ï¸ æ¸…é™¤é¸å–</button>

        <h3>2. é¡¯å¾®é¡æ ¡æ­£ (Scale)</h3>
        <div class="control-row">
            <button id="btnCalib" onclick="setTool('calib')" style="flex:1">ğŸ“ ç•«ç·šæ ¡æ­£</button>
            <label style="flex:0.2; text-align:right">1px=</label>
            <input type="number" id="pxRatio" step="0.000001" placeholder="è¼¸å…¥" oninput="manualSetScale(this.value)" style="width:70px">
            <label style="flex:0.2">mm</label>
        </div>
        <div style="font-size:11px; color:#aaa; text-align:center" id="scaleInfo">æœªæ ¡æ­£</div>

        <h3>3. å½±åƒåˆ†æåƒæ•¸</h3>
        <div class="control-row">
            <label>è‰²å½©é€šé“:</label>
            <select id="channelSel" onchange="schedulePreview()">
                <option value="gray">ç°åº¦ (Gray)</option>
                <option value="r">ç´…è‰² (R)</option>
                <option value="g">ç¶ è‰² (G)</option>
                <option value="b">è—è‰² (B)</option>
            </select>
        </div>

        <div class="control-row">
            <label>ç›®æ¨™:</label>
            <div class="btn-row" style="flex:1;">
                <button id="btnDark" onclick="setMode('dark')" class="active" style="margin:0;">æ·±è‰²</button>
                <button id="btnLight" onclick="setMode('light')" style="margin:0;">äº®è‰²</button>
            </div>
        </div>

        <label>é–¾å€¼ (Threshold): <span id="threshVal" style="color:#4FC3F7">128</span></label>
        <input type="range" id="thresholdSlider" min="0" max="255" value="128" oninput="updateThreshold(this.value)">

        <div class="control-row" style="margin-top:5px;">
            <button id="btnPick" onclick="setTool('picker')" style="border:1px dashed #aaa; flex:1;">ğŸ’‰ å¸ç®¡å»è‰²</button>
            <input type="number" id="colorTol" value="30" min="0" max="255" title="å®¹è¨±åº¦" style="width:50px" onchange="if(isPreviewing) schedulePreview()">
        </div>
        <div id="excluded-colors"></div>

        <button id="btnPreview" onclick="toggleBinaryPreview()" style="margin-top:10px; border:1px solid #555;">ğŸ‘ï¸ åˆ‡æ›é è¦½æ¨¡å¼</button>

        <button onclick="calculateArea()" class="action">â–¶ è¨ˆç®—é¢ç©</button>
        <button onclick="saveAnalysis()" style="background-color: #1976D2; border-color: #1565C0;">ğŸ’¾ å„²å­˜çµæœåœ–</button>
        
        <div class="info-box" id="resultBox">ç­‰å¾…è¨ˆç®—...</div>
    </div>

    <div id="main-area">
        <canvas id="imageCanvas"></canvas>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = { apiKey: "AIzaSyCnHhksuhJs9RdrL7DPnsAvR21ZND7kIOI", authDomain: "stack-diagram-db.firebaseapp.com", projectId: "stack-diagram-db", storageBucket: "stack-diagram-db.firebasestorage.app", messagingSenderId: "67240747982", appId: "1:67240747982:web:1fb065e40e936a7485419f", measurementId: "G-QJNE60W8BB" };
        let db = null; const COLLECTION_NAME = "glue_settings";

        try { const app = initializeApp(firebaseConfig); db = getFirestore(app); refreshCloudList(); } 
        catch(e) { console.error("Firebase Error:", e); document.getElementById('cloud-settings').innerHTML = "<option>é€£ç·šå¤±æ•—</option>"; }

        async function refreshCloudList() {
            const sel = document.getElementById('cloud-settings');
            try {
                const snapshot = await getDocs(collection(db, COLLECTION_NAME));
                sel.innerHTML = "<option value=''>-- è®€å–é›²ç«¯åƒæ•¸ --</option>";
                snapshot.forEach(doc => { const opt = document.createElement('option'); opt.value = doc.id; opt.innerText = doc.id; sel.appendChild(opt); });
            } catch(e) { sel.innerHTML = "<option>è®€å–å¤±æ•—</option>"; }
        }
        
        window.saveToCloud = async function() {
            const name = document.getElementById('setting-name').value.trim();
            if(!name) return alert("è«‹è¼¸å…¥åç¨±");
            const data = {
                threshold: parseInt(document.getElementById('thresholdSlider').value), mode: detectMode,
                channel: document.getElementById('channelSel').value, pxRatio: document.getElementById('pxRatio').value,
                pxPerMm: pxPerMm, excludedColors: excludedColors, tolerance: document.getElementById('colorTol').value, timestamp: Date.now()
            };
            try { await setDoc(doc(db, COLLECTION_NAME, name), data); alert("âœ… å·²å„²å­˜"); refreshCloudList(); } catch(e) { alert("å¤±æ•—: " + e.message); }
        };
        window.loadFromCloud = async function() {
            const name = document.getElementById('cloud-settings').value; if(!name) return;
            try {
                const docSnap = await getDoc(doc(db, COLLECTION_NAME, name));
                if(docSnap.exists()) {
                    const data = docSnap.data();
                    window.updateThreshold(data.threshold); document.getElementById('thresholdSlider').value = data.threshold;
                    window.setMode(data.mode);
                    document.getElementById('channelSel').value = data.channel || 'gray';
                    document.getElementById('pxRatio').value = data.pxRatio || '';
                    pxPerMm = data.pxPerMm || 0;
                    excludedColors = data.excludedColors || []; window.updateColorList();
                    document.getElementById('colorTol').value = data.tolerance || 30;
                    document.getElementById('setting-name').value = name;
                    document.getElementById('scaleInfo').innerText = pxPerMm > 0 ? "å·²æ ¡æ­£" : "æœªæ ¡æ­£";
                    if(img.src && isPreviewing) window.schedulePreview();
                }
            } catch(e) { alert("è®€å–å¤±æ•—"); }
        };
        window.deleteFromCloud = async function() {
            const name = document.getElementById('cloud-settings').value; if(!name) return;
            if(!confirm(`ç¢ºå®šåˆªé™¤ "${name}"ï¼Ÿ`)) return;
            try { await deleteDoc(doc(db, COLLECTION_NAME, name)); document.getElementById('setting-name').value = ""; refreshCloudList(); } catch(e) { alert("åˆªé™¤å¤±æ•—"); }
        };
    </script>

    <script>
        // --- æ ¸å¿ƒé‚è¼¯ ---
        let canvas = document.getElementById('imageCanvas');
        let ctx = canvas.getContext('2d', { willReadFrequently: true });
        let img = new Image();
        
        let currentTool = 'rect'; 
        let detectMode = 'dark'; 
        let isDrawing = false;
        let startX, startY;
        let polyPoints = [];
        let roiMask = null;
        let threshold = 128;
        let isPreviewing = false; 
        let pxPerMm = 0; 
        let calibLine = null; 
        let excludedColors = [];
        
        // æ•ˆèƒ½å„ªåŒ–è®Šæ•¸
        let renderRequest = null;

        canvas.width = 800; canvas.height = 600;
        ctx.fillStyle = "#555"; ctx.font = "20px sans-serif"; ctx.textAlign = "center";
        ctx.fillText("è«‹è¼‰å…¥åœ–ç‰‡", 400, 300);

        function loadImage(input) {
            if (input.files && input.files[0]) {
                let reader = new FileReader();
                reader.onload = function(e) {
                    img.onload = function() {
                        let maxWidth = window.innerWidth * 0.75;
                        let scale = 1;
                        if(img.width > maxWidth) scale = maxWidth / img.width;
                        canvas.width = img.width; canvas.height = img.height;
                        canvas.style.width = (img.width * scale) + "px"; canvas.style.height = (img.height * scale) + "px";
                        resetROI(); calibLine = null;
                    }
                    img.src = e.target.result;
                }
                reader.readAsDataURL(input.files[0]);
            }
        }

        window.manualSetScale = function(val) {
            let mm = parseFloat(val);
            if(!isNaN(mm) && mm > 0) { pxPerMm = 1 / mm; document.getElementById('scaleInfo').innerText = "å·²æ ¡æ­£ (æ‰‹å‹•)"; } 
            else { pxPerMm = 0; document.getElementById('scaleInfo').innerText = "æœªæ ¡æ­£"; }
        }

        window.setTool = function(tool) {
            currentTool = tool;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            // Restore UI states
            document.getElementById('btnRect').classList.toggle('active', tool === 'rect');
            document.getElementById('btnPoly').classList.toggle('active', tool === 'poly');
            document.getElementById('btnCalib').classList.toggle('active', tool === 'calib');
            document.getElementById('btnPick').classList.toggle('active', tool === 'picker');
            document.getElementById('btnDark').classList.toggle('active', detectMode === 'dark');
            document.getElementById('btnLight').classList.toggle('active', detectMode === 'light');
            if(isPreviewing) document.getElementById('btnPreview').classList.add('active'); // Keep preview state visual
            
            if(tool==='calib') alert("è«‹åœ¨ç•«é¢ä¸Šã€Œç•«ä¸€æ¢ç·šã€å°æº–åˆ»åº¦å°ºï¼Œæ»‘é¼ æ”¾é–‹å¾Œè¼¸å…¥å¯¦éš›é•·åº¦ã€‚");
        }

        window.setMode = function(mode) {
            detectMode = mode;
            document.getElementById('btnDark').classList.toggle('active', mode === 'dark');
            document.getElementById('btnLight').classList.toggle('active', mode === 'light');
            if(isPreviewing) schedulePreview();
        }
        
        window.resetROI = function() {
            polyPoints = []; roiMask = null; isPreviewing = false;
            document.getElementById('preview-tag').style.display = 'none';
            document.getElementById('btnPreview').classList.remove('active');
            drawBaseImage();
            document.getElementById('resultBox').innerHTML = "å€åŸŸå·²é‡ç½®";
        }

        window.updateThreshold = function(val) {
            threshold = parseInt(val);
            document.getElementById('threshVal').innerText = val;
            if(!isPreviewing) { isPreviewing = true; document.getElementById('preview-tag').style.display = 'block'; document.getElementById('btnPreview').classList.add('active'); }
            schedulePreview(); // ä½¿ç”¨é˜²æŠ–å‹•æ›´æ–°
        }

        window.toggleBinaryPreview = function() {
            if(!img.src) return;
            isPreviewing = !isPreviewing;
            document.getElementById('preview-tag').style.display = isPreviewing ? 'block' : 'none';
            document.getElementById('btnPreview').classList.toggle('active', isPreviewing);
            if(isPreviewing) schedulePreview(); else drawBaseImage();
        }

        // â˜…â˜…â˜… æ ¸å¿ƒå„ªåŒ–ï¼šä½¿ç”¨ requestAnimationFrame é¿å…å¡é “ â˜…â˜…â˜…
        window.schedulePreview = function() {
            if(renderRequest) cancelAnimationFrame(renderRequest);
            renderRequest = requestAnimationFrame(renderPreview);
        }

        window.updateColorList = function() {
            const container = document.getElementById('excluded-colors');
            container.innerHTML = '';
            excludedColors.forEach((c, index) => {
                const d = document.createElement('div');
                d.className = 'color-swatch';
                d.style.backgroundColor = `rgb(${c.r},${c.g},${c.b})`;
                d.onclick = () => { excludedColors.splice(index, 1); window.updateColorList(); if(isPreviewing) schedulePreview(); };
                container.appendChild(d);
            });
        }

        function drawBaseImage() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (img.src) ctx.drawImage(img, 0, 0);
            drawROI(); drawCalibration();
        }

        function drawCalibration() {
            if (calibLine) {
                ctx.strokeStyle = '#00B0FF'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(calibLine.x1, calibLine.y1); ctx.lineTo(calibLine.x2, calibLine.y2); ctx.stroke();
                ctx.fillStyle = '#00B0FF';
                ctx.beginPath(); ctx.arc(calibLine.x1, calibLine.y1, 3, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(calibLine.x2, calibLine.y2, 3, 0, Math.PI*2); ctx.fill();
            }
        }

        function drawROI() {
            ctx.strokeStyle = '#FFFF00'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
            if (roiMask) {
                ctx.beginPath();
                if (roiMask.type === 'rect') ctx.rect(roiMask.x, roiMask.y, roiMask.w, roiMask.h);
                else if (roiMask.type === 'poly') {
                    let pts = roiMask.points;
                    ctx.moveTo(pts[0].x, pts[0].y); for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
                    ctx.closePath();
                }
                ctx.stroke(); if(!isPreviewing) ctx.fill();
            }
            if (currentTool === 'poly' && polyPoints.length > 0 && !roiMask) {
                ctx.beginPath(); ctx.moveTo(polyPoints[0].x, polyPoints[0].y);
                for (let i = 1; i < polyPoints.length; i++) ctx.lineTo(polyPoints[i].x, polyPoints[i].y);
                ctx.stroke(); ctx.fillStyle='#00FF00'; for(let p of polyPoints){ctx.beginPath();ctx.arc(p.x,p.y,3,0,Math.PI*2);ctx.fill();}
            }
        }

        function getPixelValue(r, g, b, channel) {
            if(channel === 'r') return r;
            if(channel === 'g') return g;
            if(channel === 'b') return b;
            return 0.299 * r + 0.587 * g + 0.114 * b; 
        }

        function isColorExcluded(r, g, b) {
            if (excludedColors.length === 0) return false;
            const tol = parseInt(document.getElementById('colorTol').value);
            // ç°¡å–®å¿«é€Ÿçš„è·é›¢è¨ˆç®—ï¼Œé¿å… Math.sqrt æå‡æ•ˆèƒ½
            for (let c of excludedColors) {
                // ä½¿ç”¨æ›¼å“ˆé “è·é›¢è¿‘ä¼¼ï¼Œé€Ÿåº¦å¿«å¾ˆå¤š
                if (Math.abs(r-c.r) + Math.abs(g-c.g) + Math.abs(b-c.b) < tol * 2) return true;
            }
            return false;
        }

        function renderPreview() {
            if(!img.src) return;
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const channel = document.getElementById('channelSel').value;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                
                if (isColorExcluded(r, g, b)) {
                    data[i] = 100; data[i+1] = 0; data[i+2] = 100; continue; // Purple for excluded
                }

                const val = getPixelValue(r, g, b, channel);
                let isGlue = (detectMode === 'dark') ? (val < threshold) : (val > threshold);

                if (isGlue) {
                    data[i] = 0; data[i+1] = 255; data[i+2] = 255; // Cyan Highlight
                } else {
                    const gray = val * 0.4; data[i] = gray; data[i+1] = gray; data[i+2] = gray;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            drawROI(); drawCalibration();
        }

        window.calculateArea = function() {
            if (!img.src || !roiMask) { alert("è«‹å…ˆé¸å–å€åŸŸ"); return; }
            isPreviewing = false; 
            document.getElementById('preview-tag').style.display = 'none';
            document.getElementById('btnPreview').classList.remove('active');
            ctx.drawImage(img, 0, 0); 

            // 1. Create ROI Mask (offscreen)
            const maskCv = document.createElement('canvas'); maskCv.width = canvas.width; maskCv.height = canvas.height;
            const mCtx = maskCv.getContext('2d'); mCtx.fillStyle = 'white'; mCtx.beginPath();
            if (roiMask.type === 'rect') mCtx.rect(roiMask.x, roiMask.y, roiMask.w, roiMask.h);
            else { let pts = roiMask.points; mCtx.moveTo(pts[0].x, pts[0].y); for (let i = 1; i < pts.length; i++) mCtx.lineTo(pts[i].x, pts[i].y); mCtx.closePath(); }
            mCtx.fill();
            const maskData = mCtx.getImageData(0, 0, canvas.width, canvas.height).data;

            // 2. Analyze
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const channel = document.getElementById('channelSel').value;
            
            let gluePixels = 0, totalRoiPixels = 0;
            for (let i = 0; i < data.length; i += 4) {
                if (maskData[i+3] > 0) { // In ROI
                    totalRoiPixels++;
                    const r = data[i], g = data[i+1], b = data[i+2];
                    if (!isColorExcluded(r, g, b)) {
                        const val = getPixelValue(r, g, b, channel);
                        let isTarget = (detectMode === 'dark') ? (val < threshold) : (val > threshold);
                        if(isTarget) {
                            gluePixels++;
                            // Mark in Cyan
                            data[i] = 0; data[i+1] = 200; data[i+2] = 200;
                        }
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
            drawROI(); drawCalibration();

            const percent = totalRoiPixels > 0 ? ((gluePixels/totalRoiPixels)*100).toFixed(2) : 0;
            let areaText = `ROI: ${totalRoiPixels} pxÂ²<br>è† é«”: ${gluePixels} pxÂ²`;
            if (pxPerMm > 0) {
                let roiMm = (totalRoiPixels / (pxPerMm * pxPerMm)).toFixed(4);
                let glueMm = (gluePixels / (pxPerMm * pxPerMm)).toFixed(4);
                areaText = `ROI: ${totalRoiPixels} pxÂ² (<b>${roiMm} mmÂ²</b>)<br>è† é«”: ${gluePixels} pxÂ² (<b>${glueMm} mmÂ²</b>)`;
            }
            document.getElementById('resultBox').innerHTML = `${areaText}<br>æ¯”ä¾‹: <span style="font-size:18px; color:cyan">${percent}%</span>`;
        }

        window.saveAnalysis = function() {
            if (!img.src) return;
            const link = document.createElement('a'); link.download = 'analysis_result.jpg';
            link.href = canvas.toDataURL('image/jpeg', 0.9); link.click();
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
            return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
        }

        canvas.addEventListener('mousedown', e => {
            if (!img.src) return;
            const p = getPos(e);
            
            if (currentTool === 'picker') {
                const pixel = ctx.getImageData(p.x, p.y, 1, 1).data;
                excludedColors.push({ r: pixel[0], g: pixel[1], b: pixel[2] });
                window.updateColorList(); if(isPreviewing) schedulePreview();
                return;
            }
            if (currentTool === 'calib') {
                isDrawing = true; startX = p.x; startY = p.y; calibLine = null; return;
            }
            if (currentTool === 'rect') {
                isDrawing = true; startX = p.x; startY = p.y; roiMask = null; 
            } else if (currentTool === 'poly') {
                if(roiMask && (roiMask.type === 'rect' || roiMask.type === 'poly')) { polyPoints = []; roiMask = null; }
                polyPoints.push(p);
            }
            if(isPreviewing) schedulePreview(); else drawBaseImage();
        });

        canvas.addEventListener('mousemove', e => {
            if (!img.src) return;
            if (isDrawing) {
                const p = getPos(e);
                if (currentTool === 'rect') {
                    let w = p.x - startX; let h = p.y - startY;
                    roiMask = { type: 'rect', x: w<0?p.x:startX, y: h<0?p.y:startY, w: Math.abs(w), h: Math.abs(h) };
                } else if (currentTool === 'calib') {
                    calibLine = { x1: startX, y1: startY, x2: p.x, y2: p.y };
                }
                // ä½¿ç”¨ requestAnimationFrame é˜²æŠ–å‹•
                if(isPreviewing) schedulePreview(); else {
                    requestAnimationFrame(drawBaseImage); 
                }
            }
        });

        canvas.addEventListener('mouseup', e => {
            if (isDrawing) {
                isDrawing = false;
                if (currentTool === 'calib' && calibLine) {
                    let distPx = Math.sqrt(Math.pow(calibLine.x2 - calibLine.x1, 2) + Math.pow(calibLine.y2 - calibLine.y1, 2));
                    let realMm = prompt("é€™æ¢ç·šä»£è¡¨å¤šå°‘ mm?", "1");
                    if (realMm && !isNaN(realMm)) {
                        pxPerMm = distPx / parseFloat(realMm);
                        document.getElementById('scaleInfo').innerText = "å·²æ ¡æ­£";
                        document.getElementById('pxRatio').value = (1/pxPerMm).toFixed(6);
                    } else { calibLine = null; drawBaseImage(); }
                }
            }
        });

        canvas.addEventListener('dblclick', e => {
            if (currentTool === 'poly' && polyPoints.length > 2) {
                roiMask = { type: 'poly', points: [...polyPoints] };
                if(isPreviewing) schedulePreview(); else drawBaseImage();
            }
        });

    </script>
</body>
</html>
